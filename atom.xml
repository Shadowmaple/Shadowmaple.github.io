<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玄著</title>
  
  <subtitle>功不唐捐，玉汝于成</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Shadowmaple.github.io/"/>
  <updated>2019-08-15T00:34:42.292Z</updated>
  <id>https://Shadowmaple.github.io/</id>
  
  <author>
    <name>Shadow Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mongo-go的驱动使用</title>
    <link href="https://Shadowmaple.github.io/2019/08/13/Mongo-go/"/>
    <id>https://Shadowmaple.github.io/2019/08/13/Mongo-go/</id>
    <published>2019-08-13T14:46:15.000Z</published>
    <updated>2019-08-15T00:34:42.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h1><p>目前网上有两个go的mongo驱动库相对来说比较流行，一个是社区的 mgo，另一个是官方推出的”Mongo-go-driver”。mgo 是14年推出的，已经流行很久了，网上教程也非常的多，基本上google搜“mongo的go使用”的都是mgo，但是mgo已经一年多没更新过了（算是废弃了），基本上和官方的mongo脱节，不便于使用；而官方的“Mongo-go-driver”虽然推出还不到一年，网上教程也非常少，官方也没有推出很好的教程，但是长久来看，它必定是主流。所以就算现在使用官方的驱动较为困难，但也不应该成为放弃的理由。就此做下简单的学习笔记。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"context"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"go.mongodb.org/mongo-driver/bson"</span></span><br><span class="line"><span class="string">"go.mongodb.org/mongo-driver/mongo"</span></span><br><span class="line"><span class="string">"go.mongodb.org/mongo-driver/mongo/options"</span></span><br></pre></td></tr></table></figure><p>这四个基本上是必须的，其它的类似 fmt, log 就另说了</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mongodbUrl := <span class="string">"mongodb://127.0.0.1:27017"</span></span><br><span class="line">clientOptions := options.Client().ApplyURI(mongodbUrl)</span><br><span class="line"></span><br><span class="line">client, err := mongo.Connect(context.TODO(), clientOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接集合</span></span><br><span class="line">collection := client.Database(<span class="string">"table"</span>).Collection(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><h2 id="定义映射"><a href="#定义映射" class="headerlink" title="定义映射"></a>定义映射</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name<span class="keyword">string</span><span class="string">`bson:"name"`</span></span><br><span class="line">Sex     <span class="keyword">string</span><span class="string">`bson:"sex"`</span></span><br><span class="line">Age     <span class="keyword">int</span> <span class="string">`bson:"age"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的每个字段后面跟的映射存储类型为bson，bson是 一种二进制的json（Binary JSON），主要用在MongoDB之中。</p><p>看下Mongo官方对bson的解释：</p><blockquote><p>Before we start sending queries to the database, it’s important to understand how the Go Driver works with BSON objects. JSON documents in MongoDB are stored in a binary representation called BSON (Binary-encoded JSON). Unlike other databases that store JSON data as simple strings and numbers, the BSON encoding extends the JSON representation to include additional types such as int, long, date, floating point, and decimal128. This makes it much easier for applications to reliably process, sort, and compare data.</p></blockquote><h2 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加单个</span></span><br><span class="line"><span class="keyword">if</span> insertId, err := collection.InsertOne(context.TODO(), User&#123;Name: <span class="string">"Nick"</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(insertId)</span><br><span class="line">    <span class="comment">// 输出结果：&amp;&#123;ObjectID("5d5391f7b9023b91ee179295")&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个</span></span><br><span class="line">users := []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">User&#123;Name:<span class="string">"Mark"</span>, Age:<span class="number">18</span>, Sex:<span class="string">"male"</span>&#125;,</span><br><span class="line">User&#123;Name:<span class="string">"Ark"</span>, Age:<span class="number">12</span>&#125;,</span><br><span class="line">User&#123;Name:<span class="string">"Bob"</span>, Sex:<span class="string">"male"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> insertId, err := collection.InsertMany(context.TODO(), users); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(insertId)</span><br><span class="line"><span class="comment">// 输出结果：&amp;&#123;[ObjectID("5d5391f7b9023b91ee179296") ObjectID("5d5391f7b9023b91ee179297") ObjectID("5d5391f7b9023b91ee179298")]&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InsertOne</code>和<code>InsertMany</code>返回的第一个值都是有关插入文档的 Id，Id是ObjectId类型，在Mongodb中存储的字段名是”_id”，这是自动生成的，也可以自行在结构体中定义这个字段。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := collection.FindOne(context.TODO(), bson.M&#123;<span class="string">"age"</span>: <span class="number">18</span>&#125;).Decode(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(user)</span><br><span class="line">    <span class="comment">// 输出结果： &#123;Mark male 18&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得多个结果</span></span><br><span class="line">cur, err := collection.Find(context.TODO(), bson.M&#123;<span class="string">"sex"</span>: <span class="string">"male"</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须要放在错误判断之后</span></span><br><span class="line"><span class="keyword">defer</span> cur.Close(context.TODO())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代获得每一个查询结果</span></span><br><span class="line"><span class="keyword">for</span> cur.Next(context.TODO()) &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="keyword">if</span> err := cur.Decode(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(user.Name, user.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的结果理所当然的是一条或一组记录了</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="keyword">if</span> modifyResult, err := collection.UpdateOne(</span><br><span class="line">context.TODO(),</span><br><span class="line">bson.M&#123;<span class="string">"name"</span>: <span class="string">"Mark"</span>&#125;,</span><br><span class="line">bson.M&#123;<span class="string">"$set"</span>: User&#123;Name:<span class="string">"Lily"</span>, Sex:<span class="string">"female"</span>&#125;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(modifyResult)</span><br><span class="line"><span class="comment">// 输出结果： &amp;&#123;1 1 0 &lt;nil&gt;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="keyword">if</span> modifyResult, err := collection.ReplaceOne(</span><br><span class="line">context.TODO(),</span><br><span class="line">bson.M&#123;<span class="string">"name"</span>: <span class="string">"Nick"</span>&#125;,</span><br><span class="line">User&#123;Name: <span class="string">"Jack"</span>, Age: <span class="number">25</span>, Sex: <span class="string">"female"</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(modifyResult)</span><br><span class="line">    <span class="comment">//输出结果： &amp;&#123;1 1 0 &lt;nil&gt;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新和替换的区别很好理解，更新是对原有文档的某些字段进行修改，而替换则是对整个文档的取代。</p><p><code>UpdateOne</code>和<code>UpdateMany</code>的更新值必须要有<code>$</code>，作为更新的行为，以上的例子是<code>set</code>设置，还有对数字增减的<code>iner</code>、删除键的<code>unset</code>等等，更多请google “MongoDB的修改器”。</p><blockquote><p><a href="https://docs.mongodb.com/manual/reference/operator/update/" target="_blank" rel="noopener">MongoDB官方的Update operators</a></p><p><a href="https://blog.csdn.net/You_are_my_dream/article/details/57415880" target="_blank" rel="noopener">MongoDB数据库更新操作的十种修改器的使用</a></p></blockquote><p><code>UpdateOne</code>和<code>ReplaceOne</code>返回的结果都是<code>UpdateResult</code>的指针。<code>UpdateResult</code>有四个值，分别是匹配到的文档数、修改的文档数、插入的文档数和插入的 ObjectId。这样就可以理解为什么输出的结果是 <code>&amp;{1 1 0 &lt;nil&gt;}</code> 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UpdateResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The number of documents that matched the filter.</span></span><br><span class="line">    MatchedCount <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// The number of documents that were modified.</span></span><br><span class="line">    ModifiedCount <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// The number of documents that were upserted.</span></span><br><span class="line">    UpsertedCount <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// The identifier of the inserted document if an upsert took place.</span></span><br><span class="line">    UpsertedID <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除单个</span></span><br><span class="line"><span class="keyword">if</span> deleteCount, err := collection.DeleteOne(context.TODO(), bson.M&#123;<span class="string">"age"</span>: <span class="string">"Nick"</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(deleteCount)</span><br><span class="line"><span class="comment">// 输出结果： &amp;&#123;0&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多个</span></span><br><span class="line"><span class="keyword">if</span> deleteCount, err := collection.DeleteMany(context.TODO(), bson.M&#123;<span class="string">"sex"</span>: <span class="string">"male"</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(deleteCount)</span><br><span class="line"><span class="comment">// 输出结果： &amp;&#123;2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除的方法返回的第一个值是关于删除的记录（文档）数。</p><h1 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h1><h2 id="账户加密连接Mongodb"><a href="#账户加密连接Mongodb" class="headerlink" title="账户加密连接Mongodb"></a>账户加密连接Mongodb</h2><p>在实际的开发当中，我们需要以一个有确定权限的用户身份对数据库进行操作，而不是在本地默认无用户式地连接。</p><p>关于如何添加用户，这是有关Mongodb的操作，在这里就不赘述了。</p><p>具体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb:<span class="comment">//&lt;user&gt;:&lt;password&gt;@&lt;mongodb_url&gt;[/&lt;mongo_db&gt;]</span></span><br></pre></td></tr></table></figure><p>以mongodb开头，接着账户名、密码、所连接的mongo的地址，之后可以接一个连接的mongo的数据库名。因为只有在admin中添加的账户才拥有访问全部数据库的权限，所以如果不是在admin的数据库中添加的用户名却没加上其所在的db，那么连接就会报错，显示身份验证不通过。</p><p>比如连接本地mongodb（默认本地地址和端口），且这是个在table中添加的“table.admin”账户：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodbUrl := <span class="string">"mongodb://admin:secret@127.0.0.1:27017/table"</span></span><br></pre></td></tr></table></figure><h2 id="设置上下文环境"><a href="#设置上下文环境" class="headerlink" title="设置上下文环境"></a>设置上下文环境</h2><p>将<code>context.TODO()</code>作为mongo操作的上下文是十分原始的，一般情况下无伤大雅，但实际上很多时候会涉及到上下文的操作，例如用户的身份验证。在用 gin 框架开发的时候会用到 gin 上下文 <code>gin.context</code>。但如果只是mongodb的程序设置一个良好的上下文环境也是很有必要的。下面就设置了一个若超出规定时间内停止相关程序服务、释放资源上下文环境。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">client, err := mongo.NewClient(options.Client().ApplyURI(<span class="string">"mongodb://localhost:27017"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, _ := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err := client.Connect(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bson-M-和bson-D"><a href="#bson-M-和bson-D" class="headerlink" title="bson.M 和bson.D"></a><code>bson.M</code> 和<code>bson.D</code></h2><p>本人在学习的过程中，对这两者常常产生困惑，因为在一些地方出现 bson.M，另一些地方用 bson.D。但官方的演示代码中，<code>bson.D</code>总是出现，而<code>bson.M</code>却出现的很少。两者其实很类似，所谓区别其实就是一个是否有序的问题。</p><p>bson.M 是一个映射类型，而 bson.D 也是一个映射，但它却是有序的。</p><p>什么意思？看个例子：假如之前的文档没有删除完，还留有 User  结构体（字段分别为name, sex, age）的记录，那么再添加如下两条记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用，直接连err都不要了，实际的开发中显然不能如此草率</span></span><br><span class="line">_, _ = collection.InsertOne(</span><br><span class="line">context.TODO(),</span><br><span class="line">bson.M&#123;<span class="string">"city"</span>: <span class="string">"Wuhan"</span>, <span class="string">"name"</span>: <span class="string">"Ark"</span>, <span class="string">"Language"</span>: <span class="string">"Java"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;)</span><br><span class="line"></span><br><span class="line">_, _ = collection.InsertOne(</span><br><span class="line">context.TODO(),</span><br><span class="line">bson.D&#123;</span><br><span class="line">&#123;<span class="string">"city"</span>, <span class="string">"Hangzhou"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"name"</span>, <span class="string">"Nick"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"Language"</span>, <span class="string">"Go"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"age"</span>, <span class="number">20</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在mongodb中的存储结果分别为</span></span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5d53c874a22991fa217d4549"</span>), <span class="string">"age"</span> : <span class="number">18</span>, <span class="string">"city"</span> : <span class="string">"Wuhan"</span>, <span class="string">"name"</span> : <span class="string">"Ark"</span>, <span class="string">"Language"</span> : <span class="string">"Java"</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5d53c874a22991fa217d454a"</span>), <span class="string">"city"</span> : <span class="string">"Hangzhou"</span>, <span class="string">"name"</span> : <span class="string">"Nick"</span>, <span class="string">"Language"</span> : <span class="string">"Go"</span>, <span class="string">"age"</span> : <span class="number">20</span> &#125;</span><br></pre></td></tr></table></figure><p>显然，bson.D 的文档还保有定义的字段顺序，而 bson.M 却是乱了。这就是两者的区别，如此来看，还是用bson.D 比较保险，所以一般来说作为过滤的接口(filter)用 bson.M ，而存值用 bson.D 比较好。</p><p>除此之外，bson的D家族类型还有 bson.A，bson.E。bson.A 是一个bson的数组，bson.E 是一个在D中的单个元素（基本用不到）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bson.A&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="ObjectId的设置与获取"><a href="#ObjectId的设置与获取" class="headerlink" title="ObjectId的设置与获取"></a>ObjectId的设置与获取</h2><p>在实际的开发中，有时候我们需要获取mongo的“_id“字段。这就需要我们事先定义这个字段了，而不是由系统自动生成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go.mongodb.org/mongo-driver/bson/primitive"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// reset package</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id primitive.ObjectID <span class="string">`bson:"_id"`</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以像获取其它字段一样得到id了，但这时得到的id是objectId类型的，我们还要将他转换为string类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hex方法将objectid转为string</span></span><br><span class="line">idStr := id.Hex()</span><br></pre></td></tr></table></figure><p>还可以在添加文档的时候选择手动生成id</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动生成objectId</span></span><br><span class="line">id := primitive.NewObjectID()</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://github.com/mongodb/mongo-go-driver/blob/master/examples/documentation_examples/examples.go" target="_blank" rel="noopener">官方的demo</a></p></li><li><p><a href="https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial" target="_blank" rel="noopener">官方简单教程</a></p></li><li><p><a href="https://github.com/hwholiday/learning_tools/blob/master/mongodb/mongo-go-driver/main.go" target="_blank" rel="noopener">demo</a></p></li><li><p><a href="https://zh.shellman.me/articles/mongo-go-driver-demo/" target="_blank" rel="noopener">MongoDB官方推出的Go驱动库“mongo-go-driver”快速教程</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      关于Mongo-go-driver在go程序开发过程中的一些使用心得体会，简作笔记，以待查阅
    
    </summary>
    
      <category term="Go" scheme="https://Shadowmaple.github.io/categories/Go/"/>
    
    
      <category term="go" scheme="https://Shadowmaple.github.io/tags/go/"/>
    
      <category term="mongo" scheme="https://Shadowmaple.github.io/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>Linux的压缩命令</title>
    <link href="https://Shadowmaple.github.io/2019/07/31/Linux-compress/"/>
    <id>https://Shadowmaple.github.io/2019/07/31/Linux-compress/</id>
    <published>2019-07-31T10:53:58.000Z</published>
    <updated>2019-08-01T10:59:17.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的压缩命令"><a href="#常见的压缩命令" class="headerlink" title="常见的压缩命令"></a>常见的压缩命令</h1><table><thead><tr><th style="text-align:left">扩展名</th><th style="text-align:left">压缩软件</th></tr></thead><tbody><tr><td style="text-align:left">*.Z</td><td style="text-align:left">compress 软件</td></tr><tr><td style="text-align:left">*.zip</td><td style="text-align:left">zip程序</td></tr><tr><td style="text-align:left">*.gz</td><td style="text-align:left">gzip程序</td></tr><tr><td style="text-align:left">*.bz2</td><td style="text-align:left">bzip2程序</td></tr><tr><td style="text-align:left">*.xz</td><td style="text-align:left">xz 程序</td></tr><tr><td style="text-align:left">*.tar</td><td style="text-align:left">tar程序打包的文件，未压缩</td></tr><tr><td style="text-align:left">*.tar.gz</td><td style="text-align:left">tar程序打包，并经过gzip压缩</td></tr><tr><td style="text-align:left">*.tar.bz2</td><td style="text-align:left">tar程序打包，并经过bzip2压缩</td></tr><tr><td style="text-align:left">*.tar.xz</td><td style="text-align:left">tar程序打包，并经过xz压缩</td></tr></tbody></table><p>其中 compress 已基本弃用，而zip是为了支持windows而出现的，在linux中使用的也就之后的几个压缩命令。</p><h1 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h1><p>在现在的linux中，常用的单个文件压缩软件有gzip，bzip2和xz，就压缩比而言，gzip &lt; bzip2 &lt; xz，但相对的，压缩时间 gzip &lt; bzip2 &lt; xz。</p><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>gzip 是一种使用较为广泛的压缩命令，它可以解开 compress、zip和gzip等软件所压缩的文件，其压缩后的文件名为 *.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gzip [option] &#123;filename&#125;</span><br><span class="line"></span><br><span class="line">选项和参数：</span><br><span class="line">-c: 将压缩数据输出到屏幕上</span><br><span class="line">-d: 解压缩</span><br><span class="line">-k: 保留原始文件</span><br><span class="line">-v: 显示压缩信息（压缩比等）</span><br><span class="line">-n: 1-9的数字，代表压缩等级，1最差，9最好，默认为6</span><br><span class="line">-l: 列出压缩文件的相关信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 压缩文件</span><br><span class="line"><span class="meta">#</span> 这样之后压缩的文件会覆盖原始文件</span><br><span class="line"><span class="meta">$</span> gzip example.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 压缩文件，显示压缩信息，并保留源文件</span><br><span class="line"><span class="meta">#</span> 第一种方法</span><br><span class="line"><span class="meta">$</span> gzip -kv example.md</span><br><span class="line"><span class="meta">#</span> 第二种方法，使用数据流重定向</span><br><span class="line"><span class="meta">$</span> gzip -cv example.md &gt; example.md.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压缩文件</span><br><span class="line"><span class="meta">$</span> gzip -dv example.md.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用9级压缩</span><br><span class="line"><span class="meta">$</span> gzip -9v example.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示压缩文件的信息</span><br><span class="line"><span class="meta">$</span> gzip -l example.gz</span><br></pre></td></tr></table></figure><p>一般来说无论压缩还是解压缩，默认都是替换原有文件，要想保留原始文件就必须另加选项或参数。</p><p>至于压缩等级，虽然9级压缩率最好，但是时间成本会比较高，酌情使用。</p><p>使用 zcat, zmore, zless 可以读取被压缩后的压缩文件的纯文本内容。使用 zgrep 可以在压缩文件中查找纯文本内的关键字。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> zgrep "vim" example.md.gz</span><br></pre></td></tr></table></figure><h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>bzip2 是比 gzip 更好的压缩命令，其提供的压缩比更好，但相对的，它所花的压缩时间也会更久。bzip2 的用法与gzip基本相同，压缩后的文件名为 *.bz2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> bzip2 [option] [filename]</span><br><span class="line"></span><br><span class="line">选项和参数：</span><br><span class="line">-c: 将压缩数据输出到屏幕上</span><br><span class="line">-d: 解压缩</span><br><span class="line">-k: 保留原始文件</span><br><span class="line">-v: 显示压缩信息</span><br><span class="line">-n: 1-9的数字，代表压缩等级，1最差，9最好，默认为6</span><br><span class="line">-l: 列出压缩文件的相关信息</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 压缩文件，并保留原始文件</span><br><span class="line"><span class="meta">$</span> bzip2 -kv example.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压缩</span><br><span class="line"><span class="meta">$</span> bzip2 -dv example.md.bz2</span><br></pre></td></tr></table></figure><p>同样的，bzip2 也有 bzat，bzmore，bzless 和 bzgrep 使用。</p><h2 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h2><p>xz 是比 bzip2 更棒的一个压缩命令，同样的，压缩的时间成本也更高。其压缩文件为 *.xz，其用法与前两者基本相同，所以就不显示示例了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> xz [option] [filename]</span><br><span class="line"></span><br><span class="line">选项和参数：</span><br><span class="line">-c: 将压缩数据输出到屏幕上</span><br><span class="line">-d: 解压缩</span><br><span class="line">-k: 保留原始文件</span><br><span class="line">-v: 显示压缩信息</span><br><span class="line">-n: 1-9的数字，代表压缩等级，1最差，9最好，默认为6</span><br><span class="line">-l: 列出压缩文件的相关信息</span><br></pre></td></tr></table></figure><p>同样的，xz 也有 xzcat，xzmore，xzless和xzgrep。</p><h1 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h1><p>gzip，bzip2和xz只是针对单个文件进行压缩，一般情况下不能针对一个目录。但是通过 tar 对一个目录进行打包就可以进行压缩。可以用 ta r打包再 用 gzip 等进行压缩，也可以将这两个步骤合并使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 打包与压缩</span><br><span class="line"><span class="meta">$</span> tar [-z|-j|-J] [-cv] [-f 目标文件名] 被压缩文件名</span><br><span class="line"><span class="meta">#</span> 查看打包文件</span><br><span class="line"><span class="meta">$</span> tar [-z|-j|-J] [-tv] [-f 文件名]</span><br><span class="line"><span class="meta">#</span> 解压缩</span><br><span class="line"><span class="meta">$</span> tar [-z|-j|-J] [-xv] [-f 文件名] [-C 目录]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-c: 建立打包文件</span><br><span class="line">-t: 查看打包文件含有的文件</span><br><span class="line">-x: 解包或解压缩</span><br><span class="line">----------------------------------------</span><br><span class="line">-z: 使用 gzip 进行压缩，文件名为 *.tar.gz</span><br><span class="line">-j: 使用 bzip2 进行压缩，文件名为 *.tar.bz2</span><br><span class="line">-J: 使用 xz 进行压缩，文件名为 *.tar.xz</span><br><span class="line">----------------------------------------</span><br><span class="line">-v: 显示处理的文件信息</span><br><span class="line">-f : 后要跟被处理的文件名</span><br><span class="line">-C : 后跟目录名，在解压缩时解压至该目录</span><br><span class="line">----------------------------------------</span><br><span class="line">-p: 保留数据原有权限和属性</span><br><span class="line">-P: 保留绝对路径</span><br><span class="line">--exclude=FILE: 在压缩过程中，忽略该文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 示例</span><br><span class="line"><span class="meta">#</span> 打包</span><br><span class="line"><span class="meta">#</span> 若在开头加上 time 会显示程序运行时间</span><br><span class="line"><span class="meta">$</span> tar -cv -f example.tar example</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 打包并用gzip压缩</span><br><span class="line"><span class="meta">$</span> tar -zcvf example.tar.gz example</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看打包文件中所含文件</span><br><span class="line"><span class="meta">#</span> 若加上-v 则会显示文件完整（属性）信息</span><br><span class="line"><span class="meta">$</span> tar -ztf example.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解压缩至当前目录</span><br><span class="line"><span class="meta">$</span> tar -zxvf example.tar.gz -C .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux下文件压缩命令的汇总
    
    </summary>
    
      <category term="Linux" scheme="https://Shadowmaple.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://Shadowmaple.github.io/tags/linux/"/>
    
      <category term="压缩" scheme="https://Shadowmaple.github.io/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>木犀2019星计划</title>
    <link href="https://Shadowmaple.github.io/2019/07/13/muxi-project-star/"/>
    <id>https://Shadowmaple.github.io/2019/07/13/muxi-project-star/</id>
    <published>2019-07-13T12:25:35.000Z</published>
    <updated>2019-07-14T06:31:51.258Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到木犀星计划后端组的第二阶段，经过第一阶段的学习，相信同学们已经安装好了linux虚拟机，那么这次我们将尝试在linux终端上进行操作，以及学习使用文本编辑器——vim。</p><h1 id="Linux终端命令"><a href="#Linux终端命令" class="headerlink" title="Linux终端命令"></a>Linux终端命令</h1><p>linux的command何其繁多，这里只介绍一些比较常用的文件目录类命令。事先说明，在windows中的文件夹在linux中被称为目录，两者的性质其实差不多，只是名称不一样</p><p>首先，进入终端（一个小黑框）：Ctrl+Alt+t</p><h2 id="ls-显示文件列表"><a href="#ls-显示文件列表" class="headerlink" title="ls : 显示文件列表"></a>ls : 显示文件列表</h2><ul><li><code>ls</code>命令用于显示特定目录下的文件列表，可以直接显示当前目录下的文件列表，也可以加上一个目录名显示该目录下的文件列表</li><li>还有其它可选参数比如： <code>-a</code>(显示全部文件，包括隐藏文件), <code>-l</code> (显示文件的属性)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 展示当前目录下的文件列表</span></span><br><span class="line">lawler@maple:~$ ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如当前目录下有muxi这个目录，显示muxi目录下的文件</span></span><br><span class="line">lawler@maple:~$ ls muxi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示全部文件，包括隐藏文件</span></span><br><span class="line">lawler@maple:~$ ls -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示文件属性</span></span><br><span class="line">lawler@maple:~$ ls -l</span><br></pre></td></tr></table></figure></li></ul><h2 id="mkdir-新建目录"><a href="#mkdir-新建目录" class="headerlink" title="mkdir : 新建目录"></a>mkdir : 新建目录</h2><p><code>mkdir</code> 用于在当前工作目录下新建一个目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建名为muxi的目录，当然如果已经存在那么就会报错</span></span><br><span class="line">lawler@maple:~$ mkdir muxi</span><br></pre></td></tr></table></figure></p><h2 id="cd-切换当前目录"><a href="#cd-切换当前目录" class="headerlink" title="cd : 切换当前目录"></a>cd : 切换当前目录</h2><p><code>cd</code>命令用于改变当前的工作目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前是<span class="string">"~"</span>目录，即家(home)目录，进入muxi文件夹</span></span><br><span class="line">lawler@maple:~$ cd muxi</span><br><span class="line">lawler@maple:~/muxi$</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退回上一层目录</span></span><br><span class="line">lawler@maple:~/muxi$ cd ..</span><br><span class="line">lawler@maple:~$</span><br></pre></td></tr></table></figure></p><h2 id="touch-新建一个文件"><a href="#touch-新建一个文件" class="headerlink" title="touch : 新建一个文件"></a>touch : 新建一个文件</h2><p><code>touch</code> 用于在当前工作目录下新建一个文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建一个muxi.txt文件</span></span><br><span class="line">lawler@maple:~$ touch muxi.txt</span><br></pre></td></tr></table></figure></p><p>要想编辑该文件的内容，就要用到文本编辑器，其中一个便是Vim，这部分我会留到待会细说</p><h2 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm : 删除文件或目录"></a>rm : 删除文件或目录</h2><ul><li><code>rm</code> 是一个非常强大的command，它用于删除文件和目录，但要注意，在linux终端下执行的删除操作是不可逆的，也就是不可撤销的，所以用起<code>rm</code>务必慎重！</li><li>常用的可选参数：<code>-i</code> (删除前提示确认)，<code>-rf</code> (递归删除目录)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除muxi.txt文件</span></span><br><span class="line">lawler@maple:~$ rm muxi.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除前有一个确认的提示</span></span><br><span class="line">lawler@maple:~$ rm -i muxi.txt</span><br><span class="line">rm: remove regular empty file 'muxi.txt'?</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时如果确认便输入y (yes)，取消则输入n (no)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除目录及其下的子目录、文件</span></span><br><span class="line">lawler@maple:~$ rm -rf muxi</span><br></pre></td></tr></table></figure></li></ul><h2 id="mv-移动文件位置或重命名"><a href="#mv-移动文件位置或重命名" class="headerlink" title="mv : 移动文件位置或重命名"></a>mv : 移动文件位置或重命名</h2><p><code>mv</code> 有移动文件/目录位置和更名两个功能<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将muxi.txt重命名为ccnu.txt</span></span><br><span class="line">lawler@maple:~$ mv muxi.txt ccnu.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将ccnu.txt从家目录移入muxi目录中</span></span><br><span class="line">lawler@maple:~$ mv ccnu.txt muxi</span><br></pre></td></tr></table></figure></p><h2 id="cp-复制文件"><a href="#cp-复制文件" class="headerlink" title="cp : 复制文件"></a>cp : 复制文件</h2><p><code>cp</code> 可以将当前目录下的一个或多个文件复制到目标目录中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建一个muxi.md文件并将其复制到muxi目录中</span></span><br><span class="line">lawler@maple:~$ touch muxi.md</span><br><span class="line">lawler@maple:~$ cp muxi.md muxi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以试试ls命令，发现无论在~目录还是muxi目录都存在muxi.md文件</span></span><br></pre></td></tr></table></figure></p><h2 id="shutdown-关机"><a href="#shutdown-关机" class="headerlink" title="shutdown : 关机"></a>shutdown : 关机</h2><ul><li><code>shutdown</code> 作为关机命令，默认为一分钟后关机</li><li>可选参数：<code>-r</code> (重启)，<code>-c</code> (取消关机)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关机，默认一分钟后生效</span></span><br><span class="line">lawler@maple:~$ shutdown</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消关机</span></span><br><span class="line">lawler@maple:~$ shutdown -c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以选择立即关机</span></span><br><span class="line">lawler@maple:~$ shutdown now</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">lawler@maple:~$ shutdown -r</span><br></pre></td></tr></table></figure></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>具体的命令用法可以通过<code>--help</code> 或 <code>-h</code>查看<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lawler@maple:~$ cd --help</span><br></pre></td></tr></table></figure></p><h2 id="实际操练"><a href="#实际操练" class="headerlink" title="实际操练"></a>实际操练</h2><p>单纯只是看的话，学习的效率不会很高，所以还是通过一些练习来掌握吧。学长在此布置了四道十分简单的题目，可以尝试着练习一下</p><ol><li>新建一个文件 muxi.md 和一个目录 muxiBox</li><li>将 muxi.md 复制到 muxiBox 中</li><li>进入muxiBox，将 muxi.md 更名为 ccnu.txt</li><li>删除muxi.md文件</li></ol><h1 id="强大的文本编辑器——Vim"><a href="#强大的文本编辑器——Vim" class="headerlink" title="强大的文本编辑器——Vim"></a>强大的文本编辑器——Vim</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>命令行模式下的文本编辑器很多，有emacs、pico、nano、joe与vim等，但为什么一定要学vim呢？有以下几点原因：</p><blockquote><ul><li>所有的UNIX-like系统都会内置vim文本编辑器，其他的文本编辑器不一定会存在</li><li>很多软件的编辑接口都会主动调用vim（如crontab、visudo等）</li><li>vim具有程序编辑的能力，可以主动地以字体颜色辨别语法的正确性，方便程序设计</li><li>因为程序简单，编辑速度相当快速</li></ul></blockquote><p>现在就来介绍一下vim的一些基本操作</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>不出意外的话，你的系统已自带vim，就不用去安装了</p><p>用vim打开一个文件的命令如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim [filename]</span></span><br></pre></td></tr></table></figure></p><p>当这个文件不存在时，它会自动帮你创建</p><p>例如，打开muxi.txt文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim muxi.txt</span></span><br></pre></td></tr></table></figure></p><p>vim 大体上分为三个模式：一般命令模式、编辑模式和命令行模式。一开始进入vim的时候这时是一般命令模式，这时并不能编辑，而要想进入编辑模式，主要方式就是按下<code>i</code>，当你发现左下角出现<code>insert</code>或是<code>插入</code>时，就可以确定现在正处于编辑模式中了，这时你可以按下键进行常规的打字输入操作了。</p><p>而要想退出vim编辑器，则要先按下<code>Esc</code>键退回命令模式，然后输入<code>:q</code>即可退出，而要保存则要输入<code>:w</code>，具体看下表吧。</p><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">:q</td><td style="text-align:center">退出</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制退出，不保存修改</td></tr><tr><td style="text-align:center">:w</td><td style="text-align:center">保存修改</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">保存并退出</td></tr><tr><td style="text-align:center">ZZ</td><td style="text-align:center">保存并退出</td></tr></tbody></table><h2 id="命令模式的操作"><a href="#命令模式的操作" class="headerlink" title="命令模式的操作"></a>命令模式的操作</h2><p>vim与传统编辑器最大的不同就是纯靠键盘操控，比如光标定位操作，批量复制删除等。而这些操作大多数都是在一般命令模式下完成的。</p><p>一般命令模式（命令模式，普通模式），就是一开始打开的模式，在这个模式下，你可以通过键盘十分方便快速地进行定位、（批量）复制删除等操作。</p><h3 id="光标移动与定位"><a href="#光标移动与定位" class="headerlink" title="光标移动与定位"></a>光标移动与定位</h3><p>在一般命令模式下，你只需通过上下左右的方向键移动即可，当然也可以用如下方式进行移动：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h       左</span><br><span class="line"><span class="built_in">j</span>       下</span><br><span class="line">k       上</span><br><span class="line">l       右</span><br></pre></td></tr></table></figure></p><p>想快速定位可参考如下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gg      回到顶部</span><br><span class="line">G       最后一行</span><br><span class="line">[n]G    回到第n行</span><br></pre></td></tr></table></figure></p><h3 id="复制、粘贴、删除"><a href="#复制、粘贴、删除" class="headerlink" title="复制、粘贴、删除"></a>复制、粘贴、删除</h3><p>就先说下最为简单的复制粘贴和删除操作好了<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yy      复制此行</span><br><span class="line">dd      剪切此行</span><br><span class="line">p       粘贴先前复制或剪切的内容</span><br><span class="line">y[<span class="built_in">n</span>]    复制<span class="built_in">n</span>行</span><br><span class="line">d[<span class="built_in">n</span>]    粘贴<span class="built_in">n</span>行</span><br></pre></td></tr></table></figure></p><p>万一操作错误，想撤回怎么办？按下<code>u</code>就好了。</p><h2 id="实际操练-1"><a href="#实际操练-1" class="headerlink" title="实际操练"></a>实际操练</h2><p>这些命令大体上可以满足基本编辑需要了，其它的操作就自己去需要自己去学习了，下面布置了几个任务，可以尝试着去完成（注意在终端上使用vim操作）：</p><ol><li>新建一个名为 muxi.md 的文件，并用vim打开</li><li>将本文内容复制入编辑器中（ps: 终端的粘贴快捷键是Ctrl+Shift+v）</li><li>将实际操练这段内容剪切到最后一行</li><li>撤销先前操作</li><li>在命令行模式下查找“vim”这条字符串，并全部替换为”vi”</li><li>保存并退出</li></ol><p>第6道题是需要你自己去搜索学习的，加油！</p><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>linux的终端命令和vim的操作指令当然不只这一些，学长也不会介绍很多，我们只是充当一个引导者，更多的还是看你们自己。下面提供了一些文档教程（你可以去搜更好的教程），期望你们能走得更远。</p><p><a href="https://blog.csdn.net/hello_new_life/article/details/75099249" target="_blank" rel="noopener">Ubuntu 终端命令的使用</a><br><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">简明 VIM 练级攻略</a><br><a href="https://www.jianshu.com/p/bcbe916f97e1" target="_blank" rel="noopener">Vim入门基础</a></p>]]></content>
    
    <summary type="html">
    
      木犀2019星计划后端组
    
    </summary>
    
      <category term="Muxi" scheme="https://Shadowmaple.github.io/categories/Muxi/"/>
    
    
      <category term="后端" scheme="https://Shadowmaple.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="木犀" scheme="https://Shadowmaple.github.io/tags/%E6%9C%A8%E7%8A%80/"/>
    
      <category term="星计划" scheme="https://Shadowmaple.github.io/tags/%E6%98%9F%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Redis初识</title>
    <link href="https://Shadowmaple.github.io/2019/07/03/Redis_first_meet/"/>
    <id>https://Shadowmaple.github.io/2019/07/03/Redis_first_meet/</id>
    <published>2019-07-03T10:10:44.000Z</published>
    <updated>2019-07-05T08:49:58.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h1><p>redis是基于键值对的非关系型数据库</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>高性能<ul><li>纯内存存储，数据存放于内存中</li><li>单线程架构，避免竞态和线程转换</li><li>I/O多路复用技术</li></ul></li><li>基于键值对的数据结构服务器</li><li>功能丰富</li><li>简单稳定</li><li>客户端语言多</li><li>持久化</li><li>主从复制</li><li>支持高可用和分布式</li></ol><h2 id="redis可执行文件"><a href="#redis可执行文件" class="headerlink" title="redis可执行文件"></a>redis可执行文件</h2><table><thead><tr><th style="text-align:center">可执行文件</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">redis-server</td><td style="text-align:center">启动redis</td></tr><tr><td style="text-align:center">redis-cli</td><td style="text-align:center">redis命令行客户端</td></tr><tr><td style="text-align:center">redis-benchmark</td><td style="text-align:center">redis基准测试工具</td></tr><tr><td style="text-align:center">redis-check-aof</td><td style="text-align:center">redis AOF持久化文件检测和修复工具</td></tr><tr><td style="text-align:center">redis-check-dump</td><td style="text-align:center">redis RDB持久化文件检测和修复工具</td></tr><tr><td style="text-align:center">redis-sentinel</td><td style="text-align:center">启动redis sentinel</td></tr></tbody></table><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>三种方法启动Redis：默认配置、运行配置、配置文件启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭、启动、重启服务</span></span><br><span class="line">redis-cli shutdown</span><br><span class="line">/etc/init.d/redis-server stop</span><br><span class="line">/etc/init.d/redis-server start</span><br><span class="line">/etc/init.d/redis-server restart</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">~$ redis-cli -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动客户端</span></span><br><span class="line">~$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">127.0.0.1:6379&gt; exit</span><br></pre></td></tr></table></figure><h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> / mset      <span class="comment"># (批量)设置键值对</span></span><br><span class="line"><span class="keyword">keys</span> *          <span class="comment"># 查看所有键</span></span><br><span class="line">dbsize          <span class="comment"># 数据库内键值对个数</span></span><br><span class="line"><span class="keyword">exists</span>          <span class="comment"># 键是否存在</span></span><br><span class="line">del             <span class="comment"># 删除键</span></span><br><span class="line"><span class="keyword">expire</span>          <span class="comment"># 设置过期时间</span></span><br><span class="line">ttl / pttl      <span class="comment"># 查看过期时间</span></span><br><span class="line"><span class="keyword">type</span>            <span class="comment"># 键值对类型</span></span><br><span class="line">strlen          <span class="comment"># 值长度/元素个数</span></span><br><span class="line"><span class="keyword">get</span> / mget / getnx / getex      <span class="comment"># 获取键的值</span></span><br><span class="line">incr / decr / incrby / decrby / incrbyfloat     <span class="comment"># 值自增（整数/浮点数）</span></span><br></pre></td></tr></table></figure><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 插入键值对</span><br><span class="line">127.0.0.1:6379&gt; set python hello</span><br><span class="line">OK</span><br><span class="line"># 查看所有键</span><br><span class="line">127.0.0.1:6379&gt; keys *tianjia</span><br><span class="line">1) &quot;go&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line"></span><br><span class="line"># 获取值</span><br><span class="line">127.0.0.1:6379&gt; get java</span><br><span class="line">&quot;no&quot;</span><br><span class="line"># 存在键</span><br><span class="line">127.0.0.1:6379&gt; exists java</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 插入一个列表类型的键值对</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e f g</span><br><span class="line">(integer) 7</span><br><span class="line"># 查看键总数</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">append          <span class="comment"># 字符串附加</span></span><br><span class="line"><span class="keyword">rename</span>          <span class="comment"># 重命名</span></span><br><span class="line">randomkey       <span class="comment"># 随机抽取键</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库命令</span></span><br><span class="line"><span class="keyword">select</span>          <span class="comment"># 选取数据库</span></span><br><span class="line">migrate         <span class="comment"># 数据库迁移</span></span><br><span class="line">flushdb / flushall  <span class="comment"># 删除(所有)数据库</span></span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是redis中最基础的数据结构，键都是字符串类型。</p><p>字符串类型的值实际可以是字符串(简单的字符串、复杂的字符串(例如JSON、XML))、数字(整数、浮点数),甚至是二进制(图片、音频、视频),但值最大不能超过512MB</p><h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><ol><li><strong>int</strong> ：8个字节的长整型。</li><li><strong>embstr</strong> ：小于等于39个字节的字符串。</li><li><strong>raw</strong> ：大于39个字节的字符串。</li></ol><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>在Redis中,哈希类型是指键值本身又是一个键值对结构,哈希中的映射关系叫作field-value</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>哈希的全局命令基本与字符串的相同，只是在细节上以及内部实现上有一些区别<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hset</span> / hmset    <span class="comment"># 设置键值对</span></span><br><span class="line">hget / hmget    <span class="comment"># 获取</span></span><br><span class="line">hdel            <span class="comment"># 删除</span></span><br><span class="line">hlen            <span class="comment"># 计算field个数</span></span><br><span class="line">hexists         <span class="comment"># 判断field是否存在</span></span><br><span class="line">hkeys           <span class="comment"># 获取所有field</span></span><br><span class="line">hvals           <span class="comment"># 获取所有value</span></span><br><span class="line">hgetall         <span class="comment"># 获取所有的field-value</span></span><br><span class="line">hstrlen         <span class="comment"># 计算value的字符串长度</span></span><br></pre></td></tr></table></figure></p><h3 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h3><ol><li><strong>ziplist(压缩列表)</strong>：当哈希类型元素个数小于hash-max-ziplist-entries<br>配置(默认512个)、同时所有值都小于hash-max-ziplist-value配置(默认64<br>字节)时,Redis会使用ziplist作为哈希的内部实现,ziplist使用更加紧凑的<br>结构实现多个元素的连续存储,所以在节省内存方面比hashtable更加优秀。</li><li><strong>hashtable(哈希表)</strong>：当哈希类型无法满足ziplist的条件时,Redis会使<br>用hashtable作为哈希的内部实现,因为此时ziplist的读写效率会下降,而<br>hashtable的读写时间复杂度为O(1)</li></ol><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表中的每个字符串称为元素(element),一个列表最多可以存储 2^32-1 个元素</p><p>特点:<br>有序，支持索引，支持元素重复</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th style="text-align:center">操作类型</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">添加</td><td style="text-align:center">lpush rpush linsert</td></tr><tr><td style="text-align:center">删除</td><td style="text-align:center">lpop rpop lrem ltrim</td></tr><tr><td style="text-align:center">查</td><td style="text-align:center">lrange lindex llen</td></tr><tr><td style="text-align:center">更改</td><td style="text-align:center">lset</td></tr><tr><td style="text-align:center">阻塞操作</td><td style="text-align:center">blpop brpop</td></tr></tbody></table><h3 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h3><ol><li><strong>ziplist(压缩列表)</strong>:当列表的元素个数小于list-max-ziplist-entries配置<br>(默认512个),同时列表中每个元素的值都小于list-max-ziplist-value配置时<br>(默认64字节),Redis会选用ziplist来作为列表的内部实现来减少内存的使<br>用。</li><li><strong>linkedlist(链表)</strong>:当列表类型无法满足ziplist的条件时,Redis会使用<br>linkedlist作为列表的内部实现</li><li>quicklist: 以一个ziplist为节点的linkedlist</li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>特点：<br>无序，去重</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p>集合内部<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sadd        <span class="comment"># 添加</span></span><br><span class="line">srem        <span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">scard </span>      <span class="comment"># 计算元素个数</span></span><br><span class="line">sismember   <span class="comment"># 判断元素是否在集合中</span></span><br><span class="line"><span class="keyword">srandmember </span><span class="comment"># 随机返回指定个数的元素</span></span><br><span class="line">spop        <span class="comment"># 随机弹出元素</span></span><br><span class="line">smembers    <span class="comment"># 获取所有元素</span></span><br></pre></td></tr></table></figure></p><p>集合间<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sinter</span>      <span class="comment"># 交集</span></span><br><span class="line">sunion      <span class="comment"># 并集</span></span><br><span class="line">sdiff       <span class="comment"># 差集</span></span><br><span class="line">sinterstore <span class="comment"># 求交集，并将结果保存，下同</span></span><br><span class="line">sunionstore</span><br><span class="line">sdiffstore</span><br></pre></td></tr></table></figure></p><h3 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h3><ol><li><strong>intset(整数集合)</strong>:当集合中的元素都是整数且元素个数小于set-max-<br>intset-entries配置(默认512个)时,Redis会选用intset来作为集合的内部实<br>现,从而减少内存的使用。</li><li><strong>hashtable(哈希表)</strong>:当集合类型无法满足intset的条件时,Redis会使<br>用hashtable作为集合的内部实现</li></ol><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>有序，去重，通过分值实现有序，分值可重</p><h3 id="操作命令-1"><a href="#操作命令-1" class="headerlink" title="操作命令"></a>操作命令</h3><p>有序集合的全局命令基本与集合相同，但还是有一些变化</p><p>集合内部<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zadd</span><br><span class="line">zrem</span><br><span class="line">zcard</span><br><span class="line">zscore                  <span class="comment"># 获取成员分值</span></span><br><span class="line">zrank / zrevrank        <span class="comment"># 计算成员排名，根据分值默认从低到高</span></span><br><span class="line">zincrby                 <span class="comment"># 增加成员分值</span></span><br><span class="line">zrange / zrevrange      <span class="comment"># 返回指定排名范围的成员</span></span><br><span class="line">zrangebyscore / <span class="string">...</span></span><br><span class="line">zcount                  <span class="comment"># 返回指定分数范围成员个数</span></span><br><span class="line">zremrangebyrank         <span class="comment"># 删除指定排名内的升序元素</span></span><br><span class="line">zremrangebyscore</span><br></pre></td></tr></table></figure></p><p>集合间<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">zinterstore</span>     <span class="comment"># 交集</span></span><br><span class="line">zunionstore     <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure></p><h3 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h3><ol><li><strong>ziplist(压缩列表)</strong>:当有序集合的元素个数小于zset-max-ziplist-<br>entries配置(默认128个),同时每个元素的值都小于zset-max-ziplist-value配<br>置(默认64字节)时,Redis会用ziplist来作为有序集合的内部实现,ziplist<br>可以有效减少内存的使用。</li><li><strong>skiplist(跳跃表)</strong>:当ziplist条件不满足时,有序集合会使用skiplist作<br>为内部实现,因为此时ziplist的读写效率会下降</li></ol><h1 id="python中的redis"><a href="#python中的redis" class="headerlink" title="python中的redis"></a>python中的redis</h1><p>redis提供了很多的python语言的客户端，但最被广泛认可的是redis-py，本次便以redis-py 和 python3为例</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先要安装redis-py库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install redis</span><br></pre></td></tr></table></figure></p><p>其次还要将 redis 服务器开启，开启方式可以不一样<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server start</span><br></pre></td></tr></table></figure></p><blockquote><p>redis 提供 Redis 和 StrictRedis两个类，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。官方推荐使用<code>StrictRedis</code>类。</p></blockquote><h2 id="redis连接"><a href="#redis连接" class="headerlink" title="redis连接"></a>redis连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接本地的redis客户端，6479端口，默认为第一个数据库(0)，密码可设置</span></span><br><span class="line">r = redis.StrictRedis(host = <span class="string">'localhost'</span>, port = <span class="number">6379</span>, db = <span class="number">0</span>, password = <span class="literal">None</span>)</span><br><span class="line">r.set(<span class="string">'python'</span>, <span class="string">'hello'</span>)</span><br><span class="line">print(r.get(<span class="string">'python'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果为 b'hello'</span></span><br></pre></td></tr></table></figure><p>还可以用连接池 connection_pool</p><blockquote><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。<br>可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pool = redis.ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.Redis(connetion_pool = pool)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(connection_pool = pool)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.set(<span class="string">'c#'</span>, <span class="string">'bu'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'c#'</span>)</span><br><span class="line"><span class="string">b'bu'</span></span><br></pre></td></tr></table></figure><p>在python中 redis 的应用方法基本就是一般的redis应用方式，照着用就是了</p><h2 id="使用pipeline"><a href="#使用pipeline" class="headerlink" title="使用pipeline"></a>使用pipeline</h2><p>pipeline(流水线)实际上是对一组命令进行批量操作（相当于mset,mget），即将n次客户端与redis服务端之间的往返次数（RTT）合并为一次来回，有效节约在命令传输中所损耗的时间（如网络消耗）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> redis</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = redis.StrictRedis(host=<span class="string">'localhost'</span>,port=<span class="number">6379</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pipeline = r.pipeline()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pipeline.set(<span class="string">'vc'</span>, <span class="number">2</span>)       <span class="comment"># 该设置并不会执行该命令，仅相当于存在一个缓冲区</span></span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=localhost,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pipeline.incr(<span class="string">'vc'</span>)         <span class="comment"># 再将vc的值加一</span></span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=localhost,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pipeline.execute()      <span class="comment"># 执行execute后客户端才会将一组预先设定的命令传送到服务器中执行</span></span><br><span class="line">[<span class="literal">True</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.get(<span class="string">'vc'</span>)     <span class="comment"># 现在可以从服务器中得到vc的值</span></span><br><span class="line"><span class="string">b'3'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      简单记录redis相关的基础知识
    
    </summary>
    
      <category term="Redis" scheme="https://Shadowmaple.github.io/categories/Redis/"/>
    
    
      <category term="redis" scheme="https://Shadowmaple.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件查找</title>
    <link href="https://Shadowmaple.github.io/2019/07/01/Linux-file-search/"/>
    <id>https://Shadowmaple.github.io/2019/07/01/Linux-file-search/</id>
    <published>2019-07-01T03:57:18.000Z</published>
    <updated>2019-07-30T04:08:29.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脚本文件的查找"><a href="#脚本文件的查找" class="headerlink" title="脚本文件的查找"></a>脚本文件的查找</h1><h2 id="whcih"><a href="#whcih" class="headerlink" title="whcih"></a>whcih</h2><p>which 用于查找可执行文件，它是根据PATH的环境变量所规定的路径来查找文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> whcih [-a] <span class="built_in">command</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项与参数</span></span><br><span class="line">-a : 列出所有的结果</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找<span class="built_in">which</span>的文件名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> -a <span class="built_in">which</span></span></span><br><span class="line">which: shell built-in command</span><br><span class="line">/usr/bin/which</span><br><span class="line">/bin/which</span><br></pre></td></tr></table></figure><h1 id="文件的查找"><a href="#文件的查找" class="headerlink" title="文件的查找"></a>文件的查找</h1><p>在linux中，有三个命令可用于文件查找：whereis, locate, find，三者有一定的区别，各有其优劣。</p><h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>whereis 只是查找系统中某些特定目录下的文件，如 /bin/sbin 下面的执行文件和 /usrshare/man 下面的 <code>man page</code> 文件，所以查找的速度非常快。但它只是查找几个特定目录下的文件，查找范围十分有限。</p><p>可以利用 <code>whereis -l</code> 来查看 whereis 究竟查找了多少目录</p><p>whereis 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> whereis [-bmsu] &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项与参数</span></span><br><span class="line">-b: 只查找二进制文件</span><br><span class="line">-m: 只找在说明文件manuals路径下的文件</span><br><span class="line">-s: 只找源文件</span><br><span class="line">-u: 只找不在上述三个项目中的其他特殊文件</span><br></pre></td></tr></table></figure><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>locate 是从数据库（<code>/var/lib/mlocate/</code>）中查找数据，查找速度也非常快。但由于linux中的数据库默认是每天更新一次，所以当要查找在数据库更新之后才新建立的文件时，它会告诉你此文件不存在。这是一个不好的地方，但还有补救措施，可以手动更新数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> updatedb</span></span><br></pre></td></tr></table></figure><p>updatedb 会根据 <code>/etc/updatedb.conf</code> 的设置取查找系统硬盘内的文件，并更新 <code>/var/lib/mlocate</code>内的数据库文件。由于它是将数据写入数据库文件，所以需要root权限。并且因为 updatedb 是查找硬盘文件，所以可能执行速度较慢。</p><p>还有一点，locate 是根据用户输入的关键字与数据库的记录进行匹配，所以可以不像 whereis 一样必须输入完整的文件名，只需输入关键字即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> locate [-ir] &lt;keyword&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项与参数</span></span><br><span class="line">-i: 忽略大小写差异</span><br><span class="line">-r: 后面可接正则表达式的匹配方式</span><br><span class="line">-c: 只显示文件数量</span><br><span class="line">-l: 仅输出几行</span><br><span class="line">-S: 输出locate所使用的数据库文件的相关信息，包括文件目录数量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找关键字api，并仅显示10行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> locate -l 10 api</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示查询的数据库文件信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> locate -S</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find 的功能十分强大，不但能根据文件名查找文件，还能根据时间、用户、权限、文件大小等条件查找文件，并且还可以指定查找的目录（连同子目录）进行查找。但由于它是针对硬盘进行查找，十分消耗硬盘资源，速度很慢，不推荐使用，显然whereis和locate是优先选择。</p><h3 id="选项与参数"><a href="#选项与参数" class="headerlink" title="选项与参数"></a>选项与参数</h3><table><thead><tr><th style="text-align:center">选项与参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-name filename</td><td style="text-align:center">根据文件名查找文件</td></tr><tr><td style="text-align:center">-size [+-]SIZE[ck]</td><td style="text-align:center">查找大于(+)或小于(-)SIZE大小的文件，c为bytes，k为kb</td></tr><tr><td style="text-align:center">-mtime [+-]n</td><td style="text-align:center">在n天之前(+)，第n天中，n天之内(-)修改过内容的文件</td></tr><tr><td style="text-align:center">-type TYPE</td><td style="text-align:center">根据文件类型查找，类型有<strong>f, d</strong>, b, c, l, s, p</td></tr><tr><td style="text-align:center">-perm [-/]mode</td><td style="text-align:center">查找刚好等于mode，全部囊括mode（-）和包含任一mode权限（/）的文件，mode为数字形式</td></tr><tr><td style="text-align:center">-atime [+-]n</td><td style="text-align:center">同上，被读取过的文件</td></tr><tr><td style="text-align:center">-ctime [+-]n</td><td style="text-align:center">同上，修改过状态的文件</td></tr><tr><td style="text-align:center">-newer file</td><td style="text-align:center">列出比 file 还要新的文件，file 必须包含路径（绝对相对均可）</td></tr><tr><td style="text-align:center">-user name</td><td style="text-align:center">根据用户名查找该用户的文件</td></tr><tr><td style="text-align:center">-uid n</td><td style="text-align:center">根据用户ID（为数字）查找该用户的文件</td></tr><tr><td style="text-align:center">-groud name</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">-gid n</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">-nouser</td><td style="text-align:center">查找文件的拥有者不在 /etc/passed 中</td></tr><tr><td style="text-align:center">-nogroup</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">-exec cmd</td><td style="text-align:center">可接其他命令来处理查找到的结果</td></tr></tbody></table><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find [PATH] [option] [action]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在系统下查找api.md文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find / -name api.md</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下查找大于20b的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -size +20c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录下查找类型为目录的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> d</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在家目录下查找三天内修改过内容的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /home -mtime -3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找属于lawler的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -user lawler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找权限等于0664的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -perm 0664</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在上一层目录下查找比x.md新的文件且列出详细信息，并将结果输出到a.md文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find ../ -newer ./x.md -<span class="built_in">exec</span> ls -l &#123;&#125; &gt; a.md \;</span></span><br></pre></td></tr></table></figure><p><code>-exec</code> 参数中，<code>{}</code> 代表的是 find 查找到的结果，最后的 <code>\;</code> 代表命令的结束</p>]]></content>
    
    <summary type="html">
    
      Linux下文件查找命令的总结
    
    </summary>
    
      <category term="Linux" scheme="https://Shadowmaple.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://Shadowmaple.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>HomeWorks 后端开发总结</title>
    <link href="https://Shadowmaple.github.io/2019/05/12/HomeWorks-development-summary/"/>
    <id>https://Shadowmaple.github.io/2019/05/12/HomeWorks-development-summary/</id>
    <published>2019-05-12T00:18:38.000Z</published>
    <updated>2019-06-29T03:38:02.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一月底诞世，二月孵化，三月正式启动，直到5月11日完成并迎来小型产品发布会，前后历时约三个半月，开发历时约两个半月，在课余时间抽出零零散散的时间来写这个小项目，磕磕绊绊的。不过总算是结束了，不过听产品说可能要出2.0……（瑟瑟发抖）<br>说起来算是小项目，但实际上对于新手来说，涉及的东西还是需要花许些时间去学习的。<br>目前该版本涉及的技术：</p><ul><li>Python3.7</li><li>Flask框架</li><li>ORM</li><li>celery</li></ul><p>这些是比较大的部分，另外flask下面也还有flask-mail等包有使用到<br>后期若进行重构和2.0升级，要用到 Redis 和 Mysql</p><h1 id="这个项目"><a href="#这个项目" class="headerlink" title="这个项目"></a>这个项目</h1><p>先简单介绍一下这个项目吧。<br>老师在云课堂上的布置作业，学生时常会因为这样那样的原因错过ddl，于是期望云课堂作业提醒功能的出现。因此，针对这一需求，HomeWorks适时出世，提供云课堂作业查看、定时提醒，以及小组任务发布、管理这两大主要功能模块。但是后来产品组的负责人将小组任务这一模块移到了2.0迭代版，所以该项目的功能主要就是云课堂作业查看以及定时提醒。</p><h1 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h1><p>一开始听说要做 mini project 的时候，还在初步接触 Flask，感到一丝恐慌，觉得自己目前的能力还不足以完成项目的开发。什么是 API？怎么设计和应用数据库？如何和安卓合作对接？完全是一片茫然。所幸，伴随着开发时间的接近，开发流程的推进，伴随着学长们的指导以及自己的学习探索，这些未知都变为了已知。经过此次开发，已基本明白项目开发的大致流程以及一些基本的技术和方法。</p><p>二月放寒假，要说进度的话，只能说得上是学flask了，再加上被学长催着写的数据库ER图和UML图，就这样了。（果然在家学不进去），自我检讨。</p><p>三月正式开发。</p><h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><p>写API文档，写了Markdown和YAML两个版本的文档。学习Markdown版的还好，模仿前人的便可；但是YAML版的确实是花了许些时间，要学最基本的语法，然后模仿官方的例子来写。</p><h2 id="模拟登陆-amp-爬虫"><a href="#模拟登陆-amp-爬虫" class="headerlink" title="模拟登陆&amp;爬虫"></a>模拟登陆&amp;爬虫</h2><p>第三方查看云课堂作业，没有学校支持的我们，拿不到云课堂数据库，只能爬虫。所以作为后端，这个项目主要就是爬虫。爬虫有两种，一种是网页爬取，另一种是API获取，当时是后者效率高啊，用API获取相关数据。</p><p>在这个过程中，我学会了使用API爬虫的正确姿势，学会了通过分析js代码得到准确的数据。</p><p>爬取数据的前提是要模拟登陆，云课堂的登录需要验证码，这一点会比较麻烦。但是云课堂的验证码比较简单，很容易识别，即能简单地被OCR文字识别。不过后来发现验证码可以跳过。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>写API基本是按照书上flask的结构写的，照猫画虎，其实也还好。刚开始确实会有点懵，但之后就会非常熟练了。不过刚开始自己设想会用到的API肯定会和实际有出入的，需求也会改变，细节也会改善，之后便会有删减，正常2333。</p><h2 id="邮件提醒"><a href="#邮件提醒" class="headerlink" title="邮件提醒"></a>邮件提醒</h2><p>首先进行邮箱的验证，即发送验证码。这里的验证我使用username+验证码+时间戳生成一个token字符串，发送给前台，验证的时候利用该字符串、邮箱和用户输入的验证码进行验证。这一方法不太好，应该用Redis来处理。后期如果重构的话会用Redis更改。</p><p>定时提醒功能使用celery，用celery异步发送邮件的困难主要在于用于发送的邮件问题，这一点上花了比较长的时间，刚开始用的邮箱因为之前测试时候发送邮件太频繁了，导致经常被服务器标志为垃圾文件……曾用多个邮箱进行测试（gmail，qq，163，189），在发送邮件上还是用qq比较好，gmail在国内受到的阻力有点大。</p><p>然后就是调整对应时间节点的定时邮件发送了，这也花了一定的时间进行测试、调整。</p><p>呃，现在来看好像也没什么的，但在之前似乎就是花了比较长的时间。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在阿里云学生机上部署，不知道用git克隆就行了，还在网上琢磨了好久的FTP……</p><p>用nohup使得程序在后台持续运行，不会因为终端的退出之类的事件导致进程终止。</p><p>在部署期间，get到了ps进程、nohup等新的技能，并对服务器的部署有了大致的了解。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>要和产品沟通好，明确需求，不要动不动就改动API</li><li>在命名上面花的时间有点长了</li><li>代码块要加注释，方便他人了解以及后期的修改与维护</li><li>学到的东西还是蛮多的，起码知道了具体的项目开发流程，但是也有些遗憾，数据库用到的比较少，因而并没有得到什么锻炼</li></ul><p>希望之后做其他项目能吸取教训</p>]]></content>
    
    <summary type="html">
    
      简单总结第一个项目，Mini Project——HomeWorks的大致开发流程和一些问题
    
    </summary>
    
      <category term="随笔" scheme="https://Shadowmaple.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="项目开发" scheme="https://Shadowmaple.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
      <category term="后端" scheme="https://Shadowmaple.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="HomeWorks" scheme="https://Shadowmaple.github.io/tags/HomeWorks/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件属性与权限</title>
    <link href="https://Shadowmaple.github.io/2019/05/10/Linux-file-permissions/"/>
    <id>https://Shadowmaple.github.io/2019/05/10/Linux-file-permissions/</id>
    <published>2019-05-09T16:14:29.000Z</published>
    <updated>2019-07-31T00:42:59.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="权限身份"><a href="#权限身份" class="headerlink" title="权限身份"></a>权限身份</h1><p>三种身份：</p><ol><li>用户 User</li><li>群组 Group</li><li>其他人 Others</li></ol><p>用户身份和用户组记录的文件：</p><ul><li>/etc/passwd ： 存储系统账户、一般用户和root账户的相关信息（默认情况下）</li><li>/etc/shadow ： 记录个人密码</li><li>/etc/group ： 记录所有组名</li></ul><h1 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h1><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  HomeWorks 21:15:00 git:(master) ls -l</span><br><span class="line">total 132</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler<span class="number"> 26041 </span>4月 <span class="number"> 17 </span>21:19 apiDoc.yaml</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler <span class="number"> 9355 </span>4月 <span class="number"> 17 </span>21:20 api.md</span><br><span class="line">drwxrwxr-x<span class="number"> 5 </span>lawler lawler <span class="number"> 4096 </span>5月  <span class="number"> 4 </span>14:58 app</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>lawler lawler<span class="number"> 32768 </span>4月 <span class="number"> 23 </span>09:48 app.db</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler<span class="number"> 16384 </span>4月 <span class="number"> 25 </span>22:42 celerybeat-schedule</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler  <span class="number"> 201 </span>4月 <span class="number"> 16 </span>15:22 celeryout.file</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler  <span class="number"> 194 </span>4月 <span class="number"> 16 </span>08:08 celery_run.py</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler <span class="number"> 1199 </span>4月 <span class="number"> 23 </span>09:49 config.py</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler   <span class="number"> 97 </span>5月  <span class="number"> 4 </span>23:44 manage.py</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler  <span class="number"> 244 </span>4月 <span class="number"> 16 </span>15:19 myout.file</span><br><span class="line">drwxrwxr-x<span class="number"> 2 </span>lawler lawler <span class="number"> 4096 </span>4月 <span class="number"> 23 </span>09:49 __pycache__</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler   <span class="number"> 55 </span>3月 <span class="number"> 17 </span>00:14 README.md</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler  <span class="number"> 192 </span>4月 <span class="number"> 17 </span>21:48 requirement.txt</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler  <span class="number"> 116 </span>3月 <span class="number"> 30 </span>17:36 run.sh</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>lawler lawler  <span class="number"> 873 </span>3月 <span class="number"> 17 </span>12:00 test.py</span><br></pre></td></tr></table></figure><p>第一栏：文件的类型和权限<br>第一个字符表示文件的类型，permssion<br>d是目录，【-】是文件，【l】是链接文件，【b】为设备文件里的可供存储的周边设备，【c】为设备文件里面的串行端口设备，如键盘鼠标（一次性读取设备）<br>接下来的字符<br>rwx：可读可写可执行（read, write, execute）<br>分为三组，分别是文件拥有者的权限，该用户组的权限，其他人的权限</p><p>第二栏：链接节点数，incode<br>第三栏：拥有者账号<br>第四栏：所属用户组<br>第五栏：容量大小，默认为 Bytes<br>第六栏：最近的修改时间。格式为日期（月/日）和时间，但若时间过久远，便会仅显示日期和年份。使用<code>ls -l --full-time</code>显示完整的时间格式<br>第七栏：文件名</p><h1 id="权限意义"><a href="#权限意义" class="headerlink" title="权限意义"></a>权限意义</h1><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:center">ｒ</th><th style="text-align:center">w</th><th style="text-align:center">x</th></tr></thead><tbody><tr><td style="text-align:center">文件</td><td style="text-align:center">读取文件内容</td><td style="text-align:center">修改文件内容</td><td style="text-align:center">执行文件</td></tr><tr><td style="text-align:center">目录</td><td style="text-align:center">读到文件名，读取目录结构列表</td><td style="text-align:center">修改文件，包括增删文件、更名、移动</td><td style="text-align:center">进入目录</td></tr></tbody></table><p>注：</p><ol><li>在 Linux 下，[x] 权限决定文件能否被执行，这和 Windows 有所不同</li><li>文件有 [w] 权限只能对文件内容进行修改，不包含该文件的删除</li><li>若目录无 [r] 权限，则无法 list ，在某些系统和shell上甚至无法使用 [tab] 进行自动补全</li><li>从网络上下载一个文件时，其属性和权限会发生改变</li></ol><h1 id="修改文件属性和权限"><a href="#修改文件属性和权限" class="headerlink" title="修改文件属性和权限"></a>修改文件属性和权限</h1><p>chgrp： 修改文件所属用户组<br>chown： 修改文件拥有者以及用户组<br>chmod： 修改文件权限</p><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chgrp [option] grouup filename</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -R 为递归修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chgrp -R lawler blog/</span></span><br></pre></td></tr></table></figure><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">$ chown [option]<span class="built_in"> user </span>filename</span><br><span class="line">$ chown [option] user:group filename    # 也可用小数点[.]来间隔</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="comment"># chown lawler:lawler test.c</span></span><br></pre></td></tr></table></figure><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>数字类型权限表示：<code>rwx</code> –&gt; 421<br>符号类型权限表示：</p><ul><li><code>+ - =</code> –&gt; 加入，移除，设置</li><li><code>u g o a</code> –&gt; user，group，others，all</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 格式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod [option] mode filename</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数字类型修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 654 test.sh     <span class="comment"># 更改后为 -rw-r-xr--</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 符号类型修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod u=rwx,go=rx test.sh     <span class="comment"># 设置user为读写执行，用户组和其他为读执行</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R a+x blog/       <span class="comment"># 都加上可执行权限（该目录递归添加）</span></span></span><br></pre></td></tr></table></figure><h1 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h1><p>在一个文件或目录建立的时候，所使用的是系统提供的默认权限。umask 就是指定用户的默认权限值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一般权限显示的是数字</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span></span></span><br><span class="line">002</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 符号类型显示</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">umask</span> -S</span></span><br><span class="line">u=rwx,g=rwx,o=rx</span><br></pre></td></tr></table></figure><p>但要注意，umask 显示的权限值所代表的是该默认值需要减去的权限。用户建立一个文件的默认最大权限为666，而目录默认最大权限为777，则各自减去默认权限值则分别为：<code>-rw-rw-r--</code>，<code>drwxrwxr-x</code>。</p><h1 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h1><h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>Set UiD，简称为SUID，是出现在用户上的一个特殊权限（s），代表在执行特定命令中，不具有该文件所有权的该用户可以暂时获得权限。</p><p>SUID的限制与功能：</p><ul><li>SUID权限仅对二进制程序有效</li><li>执行者对于改程序需要有可执行权限</li><li>本权限仅在执行该程序的过程中有效</li><li>执行者将具有改程序拥有者的权限</li></ul><p>例如二进制可执行程序 passwd（<code>/usr/bin/passwd</code>）具有s权限，所以可以修改root用户的<code>/etc/shadow</code>，但cat（<code>/bin/cat</code>）不具有SUID权限，所以不能读取<code>/etc/shadow</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /usr/bin/passwd</span></span><br><span class="line">-rwsr-xr-x 1 root root 59K 1月  25  2018 /usr/bin/passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /bin/cat</span></span><br><span class="line">-rwxr-xr-x 1 root root 35K 1月  18  2018 /bin/cat</span><br></pre></td></tr></table></figure><p>另外要注意，SUID仅对二进制（可执行）程序有效，对shell脚本和目录无效。</p><h2 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h2><p>Set GID，简称为SGID，是出现在用户组上的一个特殊权限（s），它与SUID类似，但可以针对二进制可执行文件和目录设置。</p><p>对文件的限制功能：</p><ul><li>SGID对二进制程序有效</li><li>程序执行者对于改程序需具备x权限</li><li>执行者在执行过程中能够短暂获得程序用户组的支持</li></ul><p>对目录的限制与功能：</p><ul><li>用户若对于此目录具有r和x的权限时，该用户可进入此目录</li><li>用户在此目录下的有效用户组将会变成该目录的用户组</li><li>若用户在此目录下具有w的权限（可新建文件），则用户所建立的新文件所属的用户组与此用户组相同</li></ul><p>在目录下的功能，就是我将短暂具有该目录用户组的身份，并在此新建的东西都会变成这个用户组的，而不是我本身所属的用户组。</p><h2 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h2><p>Sticky Bit，简称为SBIT，是一个在其他权限组上的一个特殊权限（t），它只针对目录有效，它表示</p><p>SBIT的限制与功能：</p><ul><li>当用户对于该目录具有w和x权限，即具有写入的权限</li><li>当用户在该目录下建立文件或目录时，仅有自己和root才有权利删除该文件</li></ul><p>就是说我在这个目录建立了一个文件，我和root可以对它进行删除、更名、移动等一系列操作，但是他人不可删除我这个文件，我也不可以删除他人建立的文件</p><h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><p>设置SUID、SGID、SBIT权限的方式也是数字形式，但是原有的三位数字权限将会变为四位数字权限，第一位为特殊权限，其中SUID为4，SGID为2，SBIT为1。例如 4664 则为具有SUID权限。</p><p>用chmod设置即可，数字法设置的区别只是多了一位代表特殊权限的数字而已。也可以通过符号法来设置，SUID为 u+s，SGID为 g+s，SBIT为 o+t，这是加，减去则为-，大体相同。</p><p>但是当user、group、others不既有x的可执行权限时，设置了特设权限，这个特殊权限会变成大写（S和T），代表这个权限是空的。</p>]]></content>
    
    <summary type="html">
    
      对于Linux文件权限部分的所做笔记与许些总结
    
    </summary>
    
      <category term="Linux" scheme="https://Shadowmaple.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://Shadowmaple.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建github博客</title>
    <link href="https://Shadowmaple.github.io/2019/04/16/Hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"/>
    <id>https://Shadowmaple.github.io/2019/04/16/Hexo搭建github博客/</id>
    <published>2019-04-16T13:40:05.000Z</published>
    <updated>2019-04-18T12:39:35.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h1><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>搭建过程或许有那么点小繁琐<del>（其实挺麻烦的）</del>，但一旦搭建完成，发表博文是极简单，极舒服的。<br>只需要几个简单命令，你就可以完成一切。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo n <span class="comment">#写文章</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g <span class="comment">#生成</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo d <span class="comment">#部署，可与hexo g合并为 hexo d -g</span></span></span><br></pre></td></tr></table></figure></p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ul><li>已安装git</li><li>已有github账号</li><li>已有node.js</li></ul><h1 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h1><p>可以直接apt安装，也可以去官网下载node.js包，然后解压安装。在此用apt安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install npm</span></span><br></pre></td></tr></table></figure></p><p>因为npm的源在国外，没翻墙的话速度会很慢（感觉翻墙了效果也不是很大），可以改成国内的淘宝源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm config list   <span class="comment">#查看配置</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org  <span class="comment">#换源</span></span></span><br></pre></td></tr></table></figure></p><h1 id="hexo本地搭建"><a href="#hexo本地搭建" class="headerlink" title="hexo本地搭建"></a>hexo本地搭建</h1><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。一条命令即可解决：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure></p><p>如果 npm 安装 hexo 失败, 则很有可能是权限问题, 或者npm与node的版本不兼容（很少出现）</p><blockquote><p><a href="https://blog.csdn.net/cc18868876837/article/details/81542282" target="_blank" rel="noopener">npm install安装失败问题</a></p></blockquote><h2 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h2><p>创建一个目录用来作为你的 blog 目录，并在该目录中进行Hexo的初始化：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure></p><p>也可以直接<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init &lt;folder&gt;</span></span><br></pre></td></tr></table></figure></p><p>等一会儿如果出现橙色的 <code>WARN</code> 没关系，只要不出现红色的 <code>ERROR</code> 就行<br>执行后，可能会出现如下的警告，安装依赖项失败，则要手动运行 npm 安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN  Failed to install dependencies. Please run 'npm install' manually!</span><br></pre></td></tr></table></figure></p><p>手动运行安装(直接输入即可)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure></p><p>这样，hexo会帮你在该目录下生成相应的各种文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">│   ├── draft.md</span><br><span class="line">│   ├── page.md</span><br><span class="line">│   └── post.md</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br><span class="line">    └── landscape</span><br></pre></td></tr></table></figure></p><p>至此，完成了Hexo的初始化</p><h2 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h2><p>Hexo 3.0 把服务器独立成了个别模块，但要先安装 hexo-server 才能使用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install hexo-server --save</span></span><br></pre></td></tr></table></figure></p><p>之后就可以进行本地的预览了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g    <span class="comment">#等同于hexo generate, 生成静态文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s    <span class="comment">#等同于hexo server, 在本地服务器运行</span></span></span><br></pre></td></tr></table></figure></p><p>指定端口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo s -p 2333</span></span><br></pre></td></tr></table></figure></p><p>至此，Hexo博客已经在本地成功搭建<br>停止：<code>ctrl+c</code></p><h1 id="将本地Hexo博客推送到GithubPages"><a href="#将本地Hexo博客推送到GithubPages" class="headerlink" title="将本地Hexo博客推送到GithubPages"></a>将本地Hexo博客推送到GithubPages</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>仓库名为：<code>&lt;Github账号名称&gt;.github.io</code>，github会自动将它识别为Ｇithub Pages所属的仓库，并开启博客的站点链接</p><h2 id="安装-hexo-deployer-git-插件"><a href="#安装-hexo-deployer-git-插件" class="headerlink" title="安装 hexo-deployer-git 插件"></a>安装 hexo-deployer-git 插件</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><h2 id="修改站点目录下的-config-yml"><a href="#修改站点目录下的-config-yml" class="headerlink" title="修改站点目录下的_config.yml"></a>修改站点目录下的<code>_config.yml</code></h2><p>在文件末尾修改为：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> git@github.com:<span class="params">&lt;Github账号名称&gt;</span>/<span class="params">&lt;Github账号名称&gt;</span>.github.io.git</span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure></p><p>注：上面的地址可以是ssh地址，也可以是https地址</p><h2 id="添加SSH-key"><a href="#添加SSH-key" class="headerlink" title="添加SSH key"></a>添加SSH key</h2><h3 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h3><p>输入以下命令，回车三下（默认值）即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"邮箱地址"</span></span></span><br></pre></td></tr></table></figure></p><h3 id="将密钥添加到-github"><a href="#将密钥添加到-github" class="headerlink" title="将密钥添加到 github"></a>将密钥添加到 github</h3><ol><li>打开github –&gt; Settings –&gt; SSH and GPG keys –&gt; New SSH key</li><li>复制密钥文件内容（路径：<code>~/.ssh/id_rsa.pub</code>），粘贴到 New SSH Key 打开的 “Key” 之中即可，title 可随意，可不填。</li><li><p>测试是否添加成功，在命令行依次输入以下命令，返回<code>You’ve successfully authenticated</code>即成功：</p> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -T git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure></li></ol><h2 id="推送到GithubPages"><a href="#推送到GithubPages" class="headerlink" title="推送到GithubPages"></a>推送到GithubPages</h2><p>输入以下命令， 返回<code>INFO Deploy done: git</code>即成功推送<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo d</span></span><br></pre></td></tr></table></figure></p><p>等待1分钟左右，访问博客地址即可： <code>https://&lt;Github账号名称&gt;.github.io</code></p><p>可以看到初始便有一篇《Hello world》文章</p><h2 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h2><ul><li>当遇到部署出错或部署后的网页存在偏差时，建议先清理下缓存：<code>hexo clean</code></li></ul><p>我遇到 Permission denied 问题，可能你们也会踩到这个坑</p><blockquote><p><a href="https://blog.csdn.net/Zzz_Zzz_Z/article/details/80730921" target="_blank" rel="noopener">Permission denied问题</a><br><a href="http://www.cnblogs.com/xsilence/p/6001938.html" target="_blank" rel="noopener">针对github权限导致hexo部署失败的解决方案</a></p></blockquote><p>还有这一篇<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">博文</a>关于错误分析罗列得比较全</p><h2 id="hexo指令"><a href="#hexo指令" class="headerlink" title="hexo指令"></a>hexo指令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">help</span>       <span class="comment">#查看帮助</span></span><br><span class="line">hexo init       <span class="comment">#初始化一个目录</span></span><br><span class="line">hexo clean      <span class="comment">#清除缓存，最好每次执行命令前先清理缓存</span></span><br><span class="line">hexo generate   <span class="comment">#生成网页，可以在 public 目录查看整个网站的文件</span></span><br><span class="line">hexo <span class="keyword">server</span>     <span class="comment">#本地预览，'Ctrl+C'关闭</span></span><br><span class="line">hexo deploy     <span class="comment">#部署.deploy目录</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span>         <span class="comment">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"pageName"</span>    <span class="comment">#新建页面</span></span><br></pre></td></tr></table></figure><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><h2 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h2><h3 id="更改标题，作者，语言等"><a href="#更改标题，作者，语言等" class="headerlink" title="更改标题，作者，语言等"></a>更改标题，作者，语言等</h3><p>修改站点配置文件(<code>_config.yml</code>)，以博主的设置为例<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Site</span></span><br><span class="line"><span class="symbol">title:</span> 玄著 </span><br><span class="line"><span class="symbol">subtitle:</span> 记录点滴  <span class="meta">#副标题，在主标题之下显示</span></span><br><span class="line"><span class="symbol">description:</span> Coding everyday, change everyday   <span class="meta">#描述，在”作者“之下显示</span></span><br><span class="line"><span class="symbol">keywords:</span>           <span class="meta">#站点关键字，可用于被搜索引擎捕获</span></span><br><span class="line"><span class="symbol">author:</span> Shadow Zhang    <span class="meta">#作者名</span></span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-CN     <span class="meta">#语言，简体中文，更多请见官方文档</span></span><br><span class="line"><span class="symbol">timezone:</span>           <span class="meta">#时区</span></span><br></pre></td></tr></table></figure></p><p>这样就算成自己的博客了2333</p><h1 id="写博文"><a href="#写博文" class="headerlink" title="写博文"></a>写博文</h1><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>执行命令，生成指定名称的文章至<code>source/_posts/postName.md</code><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="type"></span>[layout] <span class="string">"postName"</span></span><br></pre></td></tr></table></figure></p><p>其中layout是可选参数，默认值为post。有哪些 layout 呢，请到 scaffolds 目录下查看，这些文件名称就是 layout 名称。当然你可以添加自己的 layout，方法就是添加一个文件即可，同时你也可以编辑现有的 layout，比如 post 的 layout 默认是<code>scaffolds/post.md</code></p><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>一开始新建起来的是这样的<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">postName</span>             <span class="comment">#文章标题，可以修改，但最好不要改，后面会说到</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-04</span><span class="bullet">-13</span> <span class="number">19</span><span class="string">:43:07</span>   <span class="comment">#文章生成时间，可以任意修改</span></span><br><span class="line"><span class="string">`tags`:</span>                     <span class="comment">#文章标签，可为空</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">这里开始使用markdown格式输入你的正文。</span></span><br></pre></td></tr></table></figure></p><p>多个标签（yaml格式）<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">'tags':</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">python</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">linux</span></span><br></pre></td></tr></table></figure></p><p>我们可以添加其它参数，如更新时间，分类等，详见<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="文章部分显示设置"><a href="#文章部分显示设置" class="headerlink" title="文章部分显示设置"></a>文章部分显示设置</h2><p>打开主页，我们会发现主页显示的文章都是整篇显示的，这样子不太符合我们的需求。</p><h3 id="lt-more-gt-方法"><a href="#lt-more-gt-方法" class="headerlink" title="&lt;!-- more --&gt;方法"></a><code>&lt;!-- more --&gt;</code>方法</h3><p>通常情况下，在文章中可以使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，这是Hexo提供的方式。这种方式可以精确控制需要显示的摘录内容，也可以让 Hexo 中的插件更好地对文章进行识别，比如markdown的显示。</p><p>使用：在需要的地方插入<code>&lt;!--more--&gt;</code>即可。</p><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><p>除了Hexo提供的传统方法，大多主题都提供有其它的方式，比如 NexT 主题，提供了另外两种方式：</p><ol><li>在文章的 front-matter 中添加 description，输入文章摘录即可</li><li>自动形成摘要，将主题配置中的<code>&quot;auto_excerpt</code>项，改为true即可<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span>   <span class="comment">#默认截取的长度为，可以自行设定</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h1><p>网上主题有很多，前人栽树，后人乘凉，我们只要选择一个适合自己的主题即可。可以查看<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题列表</a>，但是更多的主题未被官方收录。</p><p>我选择的主题是NexT，简洁美观，有三种外观，并且现在已经更新到了v7.1了，内部已经集成了很多模块，可以很方便地实现一些动能而无需扒前端代码（卑微）。另外还有其它人气比较高的主题，诸如：material，<a href="https://github.com/A-limon/pacman" target="_blank" rel="noopener">pacman</a>，<a href="https://github.com/orderedlist/modernist" target="_blank" rel="noopener">modernist</a>，<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>，<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a>。不多说，进入正题。</p><p>更换主题其实很简单，只要克隆主题——更改设置，即可，简单吧，<del>呵呵</del>，但实践起来还是会遇到麻烦</p><h2 id="克隆主题"><a href="#克隆主题" class="headerlink" title="克隆主题"></a>克隆主题</h2><p>进入该主题的github仓库，比如<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a>。不过可能会遇到一个主题有两个仓库的情况，比如next还有一个<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">仓库</a>，但是看它的发行版本，只有v5.14，并也宣告该仓库已停止维护。所以下载哪个，看各自的版本吧。</p><p>在hexo顶级目录下，克隆到 themes 目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure></p><p>可能在克隆过程中会因为速度过慢而失败，（此坑已踩，9kb/s…），解决办法参考<a href="https://blog.csdn.net/hzwwpgmwy/article/details/79043251" target="_blank" rel="noopener">此文</a></p><h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>打开站点配置文件（_config.yml）, 找到 theme 字段, 并将其值更改为 next<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure></p><h2 id="更改样式"><a href="#更改样式" class="headerlink" title="更改样式"></a>更改样式</h2><p>NexT有四种模式（其实只有三种，第三和第四个差不太多），直接更改主题配置文件（<code>themes/next/_config.yml</code>）的 scheme 参数即可<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Schemes</span></span><br><span class="line"><span class="meta">#scheme: Muse</span></span><br><span class="line"><span class="meta">#scheme: Mist</span></span><br><span class="line"><span class="meta">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure></p><p>然后<code>hexo s</code>即可预览效果</p><h1 id="主题优化-基于next"><a href="#主题优化-基于next" class="headerlink" title="主题优化(基于next)"></a>主题优化(基于next)</h1><h2 id="添加「标签」和「分类」页面"><a href="#添加「标签」和「分类」页面" class="headerlink" title="添加「标签」和「分类」页面"></a>添加「标签」和「分类」页面</h2><p>（以添加标签页面为例）</p><p>新建标签页面<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new page tags</span></span><br></pre></td></tr></table></figure></p><p>编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签页。文件内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-04</span><span class="bullet">-13</span> <span class="number">16</span><span class="string">:31:39</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p><p>在菜单中添加链接。编辑 主题配置文件 ， 添加 tags 到 menu 中<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home </span><br><span class="line">  <span class="meta">#about: /about/ || user</span></span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags </span><br><span class="line">  <span class="meta">#categories: /categories/ || th</span></span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive</span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure></p><p>添加“分类”或其它的菜单同理，只需把 tags 改为 categories 或其它即可。</p><p>若只是修改了主题配置文件（此坑亲测），那么点开 tags 链接会出现这样的画面：<br><img src="https://upload-images.jianshu.io/upload_images/3072214-a1cce579d49cb369.png?imageMogr2/auto-orient/" alt="tags not found"></p><h2 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h2><p>在<code>themes/next/_config.yml</code>件中搜索 avatar ：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line"><span class="attr">  url:</span> <span class="string">/uploads/avatar.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line"><span class="attr">  rounded:</span> <span class="literal">true</span>     <span class="comment"># true为圆形，false为方形</span></span><br><span class="line">  <span class="comment"># The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span></span><br><span class="line"><span class="attr">  opacity:</span> <span class="number">1</span>        <span class="comment"># 不透明度，0-1，0为透明</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line"><span class="attr">  rotated:</span> <span class="literal">false</span>    <span class="comment"># true为旋转</span></span><br></pre></td></tr></table></figure></p><p>头像图片可以放在主题目录下，也可以放在站点目录下，我选择放在站点目录下。在站点目录的 source 目录中新建 uploads 目录，用来存放头像，url 为图片地址</p><ul><li>注意：如果图片不是正方形的话，那么 rounded 参数设为 true 的话会变成椭圆形哦（亲测..）</li></ul><h2 id="返回文章顶部并显示当前浏览进度"><a href="#返回文章顶部并显示当前浏览进度" class="headerlink" title="返回文章顶部并显示当前浏览进度"></a>返回文章顶部并显示当前浏览进度</h2><p>修改<code>themes/next/_config.yml</code>，把 false 改为 true：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Back to top in sidebar</span></span><br><span class="line"><span class="attr">b2t:</span> <span class="literal">true</span>       <span class="comment"># 返回文章顶部</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span>     <span class="comment"># 当前浏览进度</span></span><br></pre></td></tr></table></figure></p><h2 id="侧边栏社交小图标设置"><a href="#侧边栏社交小图标设置" class="headerlink" title="侧边栏社交小图标设置"></a>侧边栏社交小图标设置</h2><p>打开主题配置文件<code>_config.yml</code>，搜索 Social，去掉你要添加的图标前面的#号，也可以自己添加其它的社交地址。其格式为：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[社交平台名]</span>: <span class="string">[社交地址]</span> || <span class="string">[图标名称]</span></span><br></pre></td></tr></table></figure></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">social</span>:</span><br><span class="line">  <span class="attribute">GitHub</span>: <span class="attribute">https</span>:<span class="comment">//github.com/Shadowmaple || github</span></span><br><span class="line">  <span class="attribute">E-Mail</span>: <span class="attribute">mailto</span>:shdwzhang<span class="variable">@gmail</span>.com || envelope</span><br><span class="line">  #<span class="attribute">Weibo</span>: <span class="attribute">https</span>:<span class="comment">//weibo.com/yourname || weibo</span></span><br><span class="line">  #<span class="attribute">Google</span>: <span class="attribute">https</span>:<span class="comment">//plus.google.com/yourname || google</span></span><br><span class="line">  #<span class="attribute">Twitter</span>: <span class="attribute">https</span>:<span class="comment">//twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="number">#FB</span> <span class="attribute">Page</span>: <span class="attribute">https</span>:<span class="comment">//www.facebook.com/yourname || facebook</span></span><br><span class="line">  #VK <span class="attribute">Group</span>: <span class="attribute">https</span>:<span class="comment">//vk.com/yourname || vk</span></span><br><span class="line">  #<span class="attribute">StackOverflow</span>: <span class="attribute">https</span>:<span class="comment">//stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  #<span class="attribute">YouTube</span>: <span class="attribute">https</span>:<span class="comment">//youtube.com/yourname || youtube</span></span><br><span class="line">  #<span class="attribute">Instagram</span>: <span class="attribute">https</span>:<span class="comment">//instagram.com/yourname || instagram</span></span><br><span class="line">  #<span class="attribute">Skype</span>: <span class="attribute">skype</span>:yourname?call|chat || skype</span><br><span class="line">  </span><br><span class="line"># 图标设置</span><br><span class="line"><span class="attribute">social_icons</span>:</span><br><span class="line">  <span class="attribute">enable</span>: true </span><br><span class="line">  <span class="attribute">icons_only</span>: false     #只显示图标</span><br><span class="line">  <span class="attribute">transition</span>: false</span><br><span class="line">  <span class="attribute">GitHub</span>: github</span><br></pre></td></tr></table></figure><ul><li>图标可以去<a href="https://fontawesome.com/icons?from=io" target="_blank" rel="noopener">Font Awesome Icon</a>网站去找，找到后复制名字到相应的位置即可。</li></ul><h2 id="文章代码主题设置"><a href="#文章代码主题设置" class="headerlink" title="文章代码主题设置"></a>文章代码主题设置</h2><p>NexT 共有5款主题供你选择，默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties。<br>在主题文件夹的 <code>_config.yml</code> 配置文件中，定位到 <code>highlight_theme</code>，根据需求修改相应的值即可</p><h2 id="添加nest动态背景特效"><a href="#添加nest动态背景特效" class="headerlink" title="添加nest动态背景特效"></a>添加nest动态背景特效</h2><p>背景的几何线条是采用的nest效果，一个基于html5 canvas绘制的网页背景效果，非常赞！来自github的开源项目<a href="https://github.com/hustcc/canvas-nest.js" target="_blank" rel="noopener">canvas-nest</a></p><p>效果图：<br><img src="https://yixiuer.oss-cn-shanghai.aliyuncs.com/images/hexo-next-optimization-2.gif" alt="canvas动态效果图"></p><p>而幸运的是，next主题已经内部集成了这个模块，所以就不用那么麻烦地去改js代码了</p><blockquote><p><a href="https://github.com/theme-next/theme-next-canvas-nest" target="_blank" rel="noopener">查看教程</a></p></blockquote><h2 id="主页文章添加边框阴影效果"><a href="#主页文章添加边框阴影效果" class="headerlink" title="主页文章添加边框阴影效果"></a>主页文章添加边框阴影效果</h2><p>其它主题都可以这样设置。打开 <code>themes/*/source/css/_custom/custom.styl</code> ,向里面加代码:<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">   -moz-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> rgba(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="修改底部标签样式"><a href="#修改底部标签样式" class="headerlink" title="修改底部标签样式"></a>修改底部标签样式</h2><p>修改<code>themes/next/layout/_macro/post.swig</code>文件，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>替换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。查看效果：<br><img src="https://qqadapt.qpic.cn/txdocpic/0/f30051c7389908eb2da8aecf0fe8af5a/0" alt="底部样式效果"></p><p>如果不成功，则把原来的静态资源给清除掉（<code>hexo clean</code>），重启服务。</p><h2 id="底部隐藏由Hexo强力驱动、主题–NexT-Mist"><a href="#底部隐藏由Hexo强力驱动、主题–NexT-Mist" class="headerlink" title="底部隐藏由Hexo强力驱动、主题–NexT.Mist"></a>底部隐藏由Hexo强力驱动、主题–NexT.Mist</h2><p>在主题配置文件中，搜索 powered，修改 enable 即可<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">powered:</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line"><span class="attr">  version:</span> <span class="literal">true</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line"><span class="attr">  version:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><blockquote><p>更多酷炫效果请见参考文档</p></blockquote><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></li><li><a href="https://theme-next.org/docs/getting-started/" target="_blank" rel="noopener">NexT官方文档</a></li><li><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">【持续更新】最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a></li><li><a href="http://zwd596257180.gitee.io/blog/2019/04/15/hexo_manong_bog/" target="_blank" rel="noopener">码云+Hexo搭建个人博客+评论功能接入</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#fn:2" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      简单记录一下搭建的基本过程以及遇到的一些问题
    
    </summary>
    
      <category term="Hexo" scheme="https://Shadowmaple.github.io/categories/Hexo/"/>
    
    
      <category term="linux" scheme="https://Shadowmaple.github.io/tags/linux/"/>
    
      <category term="hexo" scheme="https://Shadowmaple.github.io/tags/hexo/"/>
    
      <category term="Next" scheme="https://Shadowmaple.github.io/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Vim操作命令</title>
    <link href="https://Shadowmaple.github.io/2019/04/15/Vim%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>https://Shadowmaple.github.io/2019/04/15/Vim操作命令/</id>
    <published>2019-04-15T14:30:46.000Z</published>
    <updated>2019-04-15T15:17:15.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>简单记录一些在使用vim过程中会用到的操作<br><a id="more"></a></p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>vim有三个模式，分别是：</p><ul><li>命令模式</li><li>编辑模式<ul><li>进入：<code>[i, I, o, O, a, A, r, R]</code></li><li>退出：Esc键</li></ul></li><li>命令行模式<ul><li>进入：<code>[:, /, ?]</code></li><li>退出：Esc键</li><li>作用：查找数据，读取、保存、批量替换字符、退出、显示行号等操作</li></ul></li></ul><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="退出-amp-保存"><a href="#退出-amp-保存" class="headerlink" title="退出&amp;保存"></a>退出&amp;保存</h2><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">:q</td><td style="text-align:center">退出</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制退出，不保存修改</td></tr><tr><td style="text-align:center">:w</td><td style="text-align:center">保存修改</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">保存并退出</td></tr><tr><td style="text-align:center">ZZ</td><td style="text-align:center">保存并退出</td></tr></tbody></table><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><code>n&lt;space&gt;</code></td><td style="text-align:center">向右移动n个字符</td></tr><tr><td style="text-align:center"><code>n&lt;Enter&gt;</code></td><td style="text-align:center">向下移动n行</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">移动到非空格符的下一行</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">移动到非空格符的上一行</td></tr><tr><td style="text-align:center">[ctrl]+f</td><td style="text-align:center">向下移动一页</td></tr><tr><td style="text-align:center">[ctrl]+b</td><td style="text-align:center">向上移动一页</td></tr><tr><td style="text-align:center">[ctrl]+d</td><td style="text-align:center">向下移动半页</td></tr><tr><td style="text-align:center">[ctrl]+u</td><td style="text-align:center">向上移动半页</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">移动到最前面的字符处</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">移动到最后的字符</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">移动到此屏幕最上方一行的第一个字符</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">到屏幕中间一行的第一个字符</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">到屏幕最后一行的第一个字符</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">移动到此文件的最后一行</td></tr><tr><td style="text-align:center">nG</td><td style="text-align:center">移动到第n行</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">移动到此文件的第一行</td></tr></tbody></table><h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">/word</td><td style="text-align:center">向光标之下查找一个字符串</td></tr><tr><td style="text-align:center">?word</td><td style="text-align:center">向光标之上查找一个字符串</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">重复前一个查找操作</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">反向进行前一个查找操作</td></tr><tr><td style="text-align:center"><code>:n1,n2s/word1/word2/g</code></td><td style="text-align:center">在第n1和n2行之间寻找word1字符串，并将其替换为word2</td></tr><tr><td style="text-align:center"><code>:1,$s/word1/word2/g</code></td><td style="text-align:center">从第一行到最后一行寻找word1字符串，并将其替换为word2</td></tr><tr><td style="text-align:center"><code>:1,$s/word1/word2/gc</code></td><td style="text-align:center">从第一行到最后一行寻找word1字符串，并将其替换为word2，且在替换前显示提示字符给用户确认是否替换</td></tr><tr><td style="text-align:center">:nohl</td><td style="text-align:center">取消反白</td></tr></tbody></table><h2 id="删除、复制和粘贴"><a href="#删除、复制和粘贴" class="headerlink" title="删除、复制和粘贴"></a>删除、复制和粘贴</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">nx</td><td style="text-align:center">连续向后删除n个字符</td></tr><tr><td style="text-align:center">ndd</td><td style="text-align:center">剪切（删除）光标所在的向下n行</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">剪切该行</td></tr><tr><td style="text-align:center">d1G</td><td style="text-align:center">剪切光标所在到第一行的所有数据</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">剪切光标所在到最后一行的所有数据</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:center">剪切光标所在处，到该行的最前面的一个字符</td></tr><tr><td style="text-align:center">[n]c[k]</td><td style="text-align:center">重复删除多个数据，k为方向按键，如5cj为向下删除5，5cl为向右删除5个字符</td></tr></tbody></table><h3 id="复制与粘贴"><a href="#复制与粘贴" class="headerlink" title="复制与粘贴"></a>复制与粘贴</h3><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">yy</td><td style="text-align:center">复制所在一行</td></tr><tr><td style="text-align:center">nyy</td><td style="text-align:center">复制n行</td></tr><tr><td style="text-align:center">yn</td><td style="text-align:center">复制n+1行</td></tr><tr><td style="text-align:center">y1G</td><td style="text-align:center">复制所在行到第一行的数据</td></tr><tr><td style="text-align:center">yG</td><td style="text-align:center">复制所在行到最后一行的数据</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:center">复制所在的字符到该行行首的数据</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:center">复制所在的字符到该行行尾的数据</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">在下一行粘贴</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">在上一行粘贴</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">恢复前一个操作，撤销</td></tr><tr><td style="text-align:center">ctrl+r</td><td style="text-align:center">重做上一个操作，对撤销操作而言的撤销</td></tr></tbody></table><h2 id="命令模式切换到编辑模式"><a href="#命令模式切换到编辑模式" class="headerlink" title="命令模式切换到编辑模式"></a>命令模式切换到编辑模式</h2><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">i与I</td><td style="text-align:center">i 为从目标光标所在处插入，I 为在目前所在行的第一个非空格符处开始插入</td></tr><tr><td style="text-align:center">a与A</td><td style="text-align:center">a 为从所在的下一个字符处开始插入，A 为从所在行的最后一个字符处开始插入</td></tr><tr><td style="text-align:center">o与O</td><td style="text-align:center">o 为在所在的下一行处插入新的一行，O 为在目前所在处的上一行插入新的一行</td></tr><tr><td style="text-align:center">r与R</td><td style="text-align:center">r 只会替换光标所在的那个字符一次；R 会一直替换光标所在的文字，直到按下Esc为止</td></tr></tbody></table><h2 id="命令行模式的其它操作"><a href="#命令行模式的其它操作" class="headerlink" title="命令行模式的其它操作"></a>命令行模式的其它操作</h2><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><code>:! [command]</code></td><td style="text-align:center">暂时退出vi到shell执行command的显示结果，如<code>:! ls ~</code></td></tr><tr><td style="text-align:center"><code>:w [file]</code></td><td style="text-align:center">将编辑的数据保存成另一个文件</td></tr><tr><td style="text-align:center"><code>:f [file]</code></td><td style="text-align:center">在编辑的数据中，读入另一个文件的数据，即将此文件内容添加到光标所在行之后</td></tr><tr><td style="text-align:center"><code>:n1,n2 w [file]</code></td><td style="text-align:center">将n1到n2的内容保存到file文件</td></tr></tbody></table><h1 id="可视区块"><a href="#可视区块" class="headerlink" title="可视区块"></a>可视区块</h1><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">v</td><td style="text-align:center">字符选择，会将光标经过的地方反白选择</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">行选择， 会将光标经过的行反白选择</td></tr><tr><td style="text-align:center">[ctrl]+v</td><td style="text-align:center">可视区块，可以用矩形的方式选择数据</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">复制反白的地方</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">删除</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">将复制的区块，在光标所在处粘贴</td></tr><tr><td style="text-align:center">[Esc]</td><td style="text-align:center">退出</td></tr></tbody></table><h1 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename     # 在光标处，读取（写入）某个文件的全部内容，</span><br></pre></td></tr></table></figure><p>多文件编辑<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi file1 file2    <span class="comment"># 同时打开两个文件</span></span></span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:n</td><td style="text-align:center">编辑下一个文件</td></tr><tr><td style="text-align:center">:N</td><td style="text-align:center">编辑上一个文件</td></tr><tr><td style="text-align:center">:files</td><td style="text-align:center">列出目前这个vim开启的所有文件</td></tr></tbody></table><h1 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h1><p>多窗口同步显示：修改同步，光标移动不同步</p><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>:sp [filename]</code></td><td style="text-align:center">打开一个新窗口， 若有加filename，则表示在新窗口创建一个新文件，否则表示两个窗口为一个文件内容（同步显示）</td></tr><tr><td style="text-align:center"><code>[ctrl]+ w + j</code></td><td style="text-align:center">光标移动到下方的窗口</td></tr><tr><td style="text-align:center"><code>[ctrl]+ w + k</code></td><td style="text-align:center">光标移动到上方的窗口</td></tr><tr><td style="text-align:center"><code>[ctrl]+ w + q</code></td><td style="text-align:center">退出，也可用<code>:q</code>或<code>:close</code></td></tr></tbody></table><h1 id="关键字补全"><a href="#关键字补全" class="headerlink" title="关键字补全"></a>关键字补全</h1><p>组合键，要在编辑模式下使用</p><table><thead><tr><th style="text-align:center">command</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">ctrl+x -&gt; ctrl+n</td><td style="text-align:center">通过目前正在编辑的这个【文件的内容文字】作为关键字，予以补全</td></tr><tr><td style="text-align:center">ctrl+x -&gt; ctrl+f</td><td style="text-align:center">以当前目录内的【文件名】作为关键词，予以补全</td></tr><tr><td style="text-align:center">ctrl+x -&gt; ctrl+o</td><td style="text-align:center">以扩展名作为语法补充，以vim内置的关键词，予以补全</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;简单记录一些在使用vim过程中会用到的操作&lt;br&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://Shadowmaple.github.io/categories/Vim/"/>
    
    
      <category term="linux" scheme="https://Shadowmaple.github.io/tags/linux/"/>
    
      <category term="vim" scheme="https://Shadowmaple.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器</title>
    <link href="https://Shadowmaple.github.io/2019/04/13/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://Shadowmaple.github.io/2019/04/13/python装饰器/</id>
    <published>2019-04-12T16:49:40.000Z</published>
    <updated>2019-04-17T02:07:10.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用装饰器？"><a href="#为什么要用装饰器？" class="headerlink" title="为什么要用装饰器？"></a>为什么要用装饰器？</h1><p>先看一个简单的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'm foo."</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><p>之后有了一个新需求，想要在其中添加时间，你可以这样直接添加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    t = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br><span class="line">    print(<span class="string">'It\'s &#123;&#125; now.'</span>.format(t))</span><br><span class="line">    print(<span class="string">"I am foo."</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><p>先来看下效果<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">It's <span class="number">15</span>:<span class="number">15</span>:<span class="number">15</span> now.</span><br><span class="line">I am foo.</span><br></pre></td></tr></table></figure></p><p>成功达成目的，但是这样的话，我们每次都要修改函数代码，如果有多个函数的话，效率极为低下。那么这种方式呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    t = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br><span class="line">    print(<span class="string">'It\'s &#123;&#125; now.'</span>.format(t))</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am foo."</span>)</span><br><span class="line"></span><br><span class="line">get_time(foo)</span><br></pre></td></tr></table></figure></p><p>当然可以。但是这种代码已经破坏了原有的代码逻辑，执行方式改变了，之前是执行运行foo()，而现在却只能运行get_time(foo)。那么有没有更好的方式呢？答案是装饰器。</p><h1 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h1><p>简单来讲，装饰器就是一个在不破坏原有代码逻辑、结构的情况下对既有函数方法进行附加功能的函数或类。它的本质就是函数或类。</p><h2 id="简单的装饰器"><a href="#简单的装饰器" class="headerlink" title="简单的装饰器"></a>简单的装饰器</h2><p>首先要认识到在python中函数是一等公民，即函数也是对象，也是可以作为参数进行传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        t = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br><span class="line">        print(<span class="string">'It\'s &#123;&#125; now.'</span>.format(t))</span><br><span class="line">        <span class="keyword">return</span> foo()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am foo."</span>)</span><br><span class="line"></span><br><span class="line">foo = get_time(foo)</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>函数<code>get_time</code>就是装饰器，它把执行真正业务方法的func包裹在函数里面，看起来像foo被<code>get_time</code>装饰了。</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        t = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br><span class="line">        print(<span class="string">'It\'s &#123;&#125; now.'</span>.format(t))</span><br><span class="line">        <span class="keyword">return</span> foo()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_time               #加上语法糖，=&gt; foo = get_time(foo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am foo."</span>)</span><br></pre></td></tr></table></figure></p><h2 id="装饰器的调用顺序"><a href="#装饰器的调用顺序" class="headerlink" title="装饰器的调用顺序"></a>装饰器的调用顺序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>装饰器的调用顺序是从下到上的，即<code>foo = a(b(c(foo)))</code></p><h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>装饰器的语法允许我们在调用时，提供其它参数。这样，就为装饰器的编写和使用提供了更大的灵活性。</p><h2 id="关于-args-kwargs"><a href="#关于-args-kwargs" class="headerlink" title="关于*args, **kwargs"></a>关于*args, **kwargs</h2><p>我们所要装饰的函数有很多是需要参数的，所以说我们可能会想到在wrapper()直接添加参数，但是如果函数所需要的参数个数是不确定的，那如果每次都修改所定义的装饰器，那么装饰器便失去了其普适性。所以引入了<code>*args</code> 和<code>**kwargs</code>支持接受动态参数。</p><ul><li><code>*args</code>表示任何多个无名参数，它是一个tuple</li><li><code>**kwargs</code>表示关键字参数，它是一个dict.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            t = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br><span class="line">            print(<span class="string">'It\'s &#123;&#125; now.'</span>.format(t))</span><br><span class="line">            print(<span class="string">'I am &#123;&#125;.'</span>.format(name))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_time(name='Shadow')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'Nick'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, I'm %s."</span> %name)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'Mark'</span>)</span><br></pre></td></tr></table></figure><h1 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h1><p>相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的<code>__call__</code>方法，当使用@形式将装饰器附加到函数上时，就会调用此方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator runing'</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator ending'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure></p><h1 id="装饰器的弊端"><a href="#装饰器的弊端" class="headerlink" title="装饰器的弊端"></a>装饰器的弊端</h1><p>虽然装饰器实现了我们的功能，但是借助这个<a href="http://www.pythontutor.com/visualize.html#mode=edit" target="_blank" rel="noopener">网站</a>来观察返回的函数foo，我们会发现其名称将不会再是原函数的名称,即它的原信息发生了改变，这说明装饰器对原函数造成了影响，这是我们不愿意见到的。所以我们使用python的<code>functools</code>包中一个装饰器<code>wraps</code>来消除这个副作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            t = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br><span class="line">            print(<span class="string">'It\'s &#123;&#125; now.'</span>.format(t))</span><br><span class="line">            print(<span class="string">'I am &#123;&#125;.'</span>.format(name))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_time(name='Shadow')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'Nick'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, I'm %s."</span> %name)</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'Mark'</span>)</span><br></pre></td></tr></table></figure><h1 id="装饰器的执行顺序"><a href="#装饰器的执行顺序" class="headerlink" title="装饰器的执行顺序"></a>装饰器的执行顺序</h1><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"running decorator"</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running foo"</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p><p>这就有运行和导入之分。导入时：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> decorator</span><br><span class="line"><span class="built_in">running</span> decorator</span><br></pre></td></tr></table></figure></p><p><code>foo()</code>只有在运行时才会运行</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>明确三个变量：全局变量，局部变量和自由变量。</p><p>自由变量，指未在本地作用域中绑定的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    lt = [<span class="string">'abc'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(lt)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>在上述代码中，在<code>wrapper</code>中<code>lt</code>即是自由变量。从<code>lt = [&#39;abc&#39;]</code>到<code>return func</code>之间（包括）即是闭包。</p><p>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。但是只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要用装饰器？&quot;&gt;&lt;a href=&quot;#为什么要用装饰器？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用装饰器？&quot;&gt;&lt;/a&gt;为什么要用装饰器？&lt;/h1&gt;&lt;p&gt;先看一个简单的例子&lt;br&gt;&lt;figure class=&quot;highlight pyth
      
    
    </summary>
    
      <category term="Python" scheme="https://Shadowmaple.github.io/categories/Python/"/>
    
    
      <category term="python" scheme="https://Shadowmaple.github.io/tags/python/"/>
    
  </entry>
  
</feed>
