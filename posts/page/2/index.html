<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Posts - Mannix&#39;s blog</title>
  <meta name="author" content="Mannix"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Mannix\x27s blog",
    
    "url": "https:\/\/Shadowmaple.github.io"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/Shadowmaple.github.io"
  
  
  
  
}
</script>

<meta property="og:title" content="Posts" />
<meta property="og:url" content="https://Shadowmaple.github.io/posts/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Mannix&#39;s blog" />

  <meta name="twitter:title" content="Posts" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.68.3" />
  <link rel="alternate" href="https://Shadowmaple.github.io/index.xml" type="application/rss+xml" title="Mannix&#39;s blog"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://Shadowmaple.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="https://Shadowmaple.github.io/css/syntax.css" /><link rel="stylesheet" href="https://Shadowmaple.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://Shadowmaple.github.io">Mannix&#39;s blog</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="主页" href="/">主页</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/posts/">归档</a>
            </li>
          
        
          
            <li>
              <a title="分类" href="/categories/">分类</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags/">标签</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/about/">关于</a>
            </li>
          
        

        

        
      </ul>
    </div>

    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="posts-heading">
              
                <h1>Posts</h1>
              
              
                <hr class="small">
              
              
              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
  <div class="container" role="main">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        
        <div class="posts-list">
          
            <article class="post-preview">
    <a href="https://Shadowmaple.github.io/posts/linux-compress/">
        <h2 class="post-title"> Linux的压缩命令</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 July 31, 2019
  
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Mannix
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h1 id="常见的压缩命令">常见的压缩命令</h1>
<table>
<thead>
<tr>
<th align="left">扩展名</th>
<th align="left">压缩软件</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">*.Z</td>
<td align="left">compress 软件</td>
</tr>
<tr>
<td align="left">*.zip</td>
<td align="left">zip程序</td>
</tr>
<tr>
<td align="left">*.gz</td>
<td align="left">gzip程序</td>
</tr>
<tr>
<td align="left">*.bz2</td>
<td align="left">bzip2程序</td>
</tr>
<tr>
<td align="left">*.xz</td>
<td align="left">xz 程序</td>
</tr>
<tr>
<td align="left">*.tar</td>
<td align="left">tar程序打包的文件，未压缩</td>
</tr>
<tr>
<td align="left">*.tar.gz</td>
<td align="left">tar程序打包，并经过gzip压缩</td>
</tr>
<tr>
<td align="left">*.tar.bz2</td>
<td align="left">tar程序打包，并经过bzip2压缩</td>
</tr>
<tr>
<td align="left">*.tar.xz</td>
<td align="left">tar程序打包，并经过xz压缩</td>
</tr>
</tbody>
</table>
<p>其中 compress 已基本弃用，而zip是为了支持windows而出现的，在linux中使用的也就之后的几个压缩命令。</p>
<h1 id="文件压缩">文件压缩</h1>
<p>在现在的linux中，常用的单个文件压缩软件有gzip，bzip2和xz，就压缩比而言，gzip &lt; bzip2 &lt; xz，但相对的，压缩时间 gzip &lt; bzip2 &lt; xz。</p>
<h2 id="gzip">gzip</h2>
<p>gzip 是一种使用较为广泛的压缩命令，它可以解开 compress、zip和gzip等软件所压缩的文件，其压缩后的文件名为 *.gz</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ gzip <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> <span style="color:#f92672">{</span>filename<span style="color:#f92672">}</span>

选项和参数：
-c	: 将压缩数据输出到屏幕上
-d	: 解压缩
-k	: 保留原始文件
-v	: 显示压缩信息（压缩比等）
-n	: 1-9的数字，代表压缩等级，1最差，9最好，默认为6
-l	: 列出压缩文件的相关信息

<span style="color:#75715e"># 压缩文件</span>
<span style="color:#75715e"># 这样之后压缩的文件会覆盖原始文件</span>
$ gzip example.md

<span style="color:#75715e"># 压缩文件，显示压缩信息，并保留源文件</span>
<span style="color:#75715e"># 第一种方法</span>
$ gzip -kv example.md
<span style="color:#75715e"># 第二种方法，使用数据流重定向</span>
$ gzip -cv example.md &gt; example.md.gz

<span style="color:#75715e"># 解压缩文件</span>
$ gzip -dv example.md.gz

<span style="color:#75715e"># 使用9级压缩</span>
$ gzip -9v example.md

<span style="color:#75715e"># 显示压缩文件的信息</span>
$ gzip -l example.gz
</code></pre></div><p>一般来说无论压缩还是解压缩，默认都是替换原有文件，要想保留原始文件就必须另加选项或参数。</p>
<p>至于压缩等级，虽然9级压缩率最好，但是时间成本会比较高，酌情使用。</p>
<p>使用 zcat, zmore, zless 可以读取被压缩后的压缩文件的纯文本内容。使用 zgrep 可以在压缩文件中查找纯文本内的关键字。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ zgrep <span style="color:#e6db74">&#34;vim&#34;</span> example.md.gz
</code></pre></div><h2 id="bzip2">bzip2</h2>
<p>bzip2 是比 gzip 更好的压缩命令，其提供的压缩比更好，但相对的，它所花的压缩时间也会更久。bzip2 的用法与gzip基本相同，压缩后的文件名为 *.bz2</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ bzip2 <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>filename<span style="color:#f92672">]</span>

选项和参数：
-c	: 将压缩数据输出到屏幕上
-d	: 解压缩
-k	: 保留原始文件
-v	: 显示压缩信息
-n	: 1-9的数字，代表压缩等级，1最差，9最好，默认为6
-l	: 列出压缩文件的相关信息

<span style="color:#75715e"># 压缩文件，并保留原始文件</span>
$ bzip2 -kv example.md

<span style="color:#75715e"># 解压缩</span>
$ bzip2 -dv example.md.bz2
</code></pre></div><p>同样的，bzip2 也有 bzat，bzmore，bzless 和 bzgrep 使用。</p>
<h2 id="xz">xz</h2>
<p>xz 是比 bzip2 更棒的一个压缩命令，同样的，压缩的时间成本也更高。其压缩文件为 *.xz，其用法与前两者基本相同，所以就不显示示例了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ xz <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>filename<span style="color:#f92672">]</span>

选项和参数：
-c	: 将压缩数据输出到屏幕上
-d	: 解压缩
-k	: 保留原始文件
-v	: 显示压缩信息
-n	: 1-9的数字，代表压缩等级，1最差，9最好，默认为6
-l	: 列出压缩文件的相关信息
</code></pre></div><p>同样的，xz 也有 xzcat，xzmore，xzless和xzgrep。</p>
<h1 id="打包压缩">打包压缩</h1>
<p>gzip，bzip2和xz只是针对单个文件进行压缩，一般情况下不能针对一个目录。但是通过 tar 对一个目录进行打包就可以进行压缩。可以用 ta r打包再 用 gzip 等进行压缩，也可以将这两个步骤合并使用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 打包与压缩</span>
$ tar <span style="color:#f92672">[</span>-z|-j|-J<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-cv<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-f 目标文件名<span style="color:#f92672">]</span> 被压缩文件名
<span style="color:#75715e"># 查看打包文件</span>
$ tar <span style="color:#f92672">[</span>-z|-j|-J<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-tv<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-f 文件名<span style="color:#f92672">]</span>
<span style="color:#75715e"># 解压缩</span>
$ tar <span style="color:#f92672">[</span>-z|-j|-J<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-xv<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-f 文件名<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>-C 目录<span style="color:#f92672">]</span>

选项与参数：
-c	: 建立打包文件
-t	: 查看打包文件含有的文件
-x	: 解包或解压缩
----------------------------------------
-z	: 使用 gzip 进行压缩，文件名为 *.tar.gz
-j	: 使用 bzip2 进行压缩，文件名为 *.tar.bz2
-J	: 使用 xz 进行压缩，文件名为 *.tar.xz
----------------------------------------
-v	: 显示处理的文件信息
-f 	: 后要跟被处理的文件名
-C 	: 后跟目录名，在解压缩时解压至该目录
----------------------------------------
-p	: 保留数据原有权限和属性
-P	: 保留绝对路径
--exclude<span style="color:#f92672">=</span>FILE	: 在压缩过程中，忽略该文件


<span style="color:#75715e"># 示例</span>
<span style="color:#75715e"># 打包</span>
<span style="color:#75715e"># 若在开头加上 time 会显示程序运行时间</span>
$ tar -cv -f example.tar example

<span style="color:#75715e"># 打包并用gzip压缩</span>
$ tar -zcvf example.tar.gz example

<span style="color:#75715e"># 查看打包文件中所含文件</span>
<span style="color:#75715e"># 若加上-v 则会显示文件完整（属性）信息</span>
$ tar -ztf example.tar.gz

<span style="color:#75715e"># 解压缩至当前目录</span>
$ tar -zxvf example.tar.gz -C .
</code></pre></div>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://Shadowmaple.github.io/tags/linux/">linux</a>&nbsp;
        
        <a href="https://Shadowmaple.github.io/tags/%E5%8E%8B%E7%BC%A9/">压缩</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://Shadowmaple.github.io/posts/redis_first_meet/">
        <h2 class="post-title">Redis初识</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 July 3, 2019
  
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Mannix
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h1 id="认识">认识</h1>
<p>redis是基于键值对的非关系型数据库</p>
<h2 id="特性">特性</h2>
<ol>
<li>高性能
<ul>
<li>纯内存存储，数据存放于内存中</li>
<li>单线程架构，避免竞态和线程转换</li>
<li>I/O多路复用技术</li>
</ul>
</li>
<li>基于键值对的数据结构服务器</li>
<li>功能丰富</li>
<li>简单稳定</li>
<li>客户端语言多</li>
<li>持久化</li>
<li>主从复制</li>
<li>支持高可用和分布式</li>
</ol>
<h2 id="redis可执行文件">redis可执行文件</h2>
<table>
<thead>
<tr>
<th align="center">可执行文件</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">redis-server</td>
<td align="center">启动redis</td>
</tr>
<tr>
<td align="center">redis-cli</td>
<td align="center">redis命令行客户端</td>
</tr>
<tr>
<td align="center">redis-benchmark</td>
<td align="center">redis基准测试工具</td>
</tr>
<tr>
<td align="center">redis-check-aof</td>
<td align="center">redis AOF持久化文件检测和修复工具</td>
</tr>
<tr>
<td align="center">redis-check-dump</td>
<td align="center">redis RDB持久化文件检测和修复工具</td>
</tr>
<tr>
<td align="center">redis-sentinel</td>
<td align="center">启动redis sentinel</td>
</tr>
</tbody>
</table>
<h1 id="运行">运行</h1>
<p>三种方法启动Redis：默认配置、运行配置、配置文件启动</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 关闭、启动、重启服务</span>
redis-cli shutdown
/etc/init.d/redis-server stop
/etc/init.d/redis-server start
/etc/init.d/redis-server restart
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 查看版本</span>
~$ redis-cli -v

<span style="color:#75715e"># 启动客户端</span>
~$ redis-cli
127.0.0.1:6379&gt;
<span style="color:#75715e"># 退出</span>
127.0.0.1:6379&gt; exit
</code></pre></div><h1 id="操作命令">操作命令</h1>
<h2 id="常用命令">常用命令</h2>
<pre><code>set / mset      # (批量)设置键值对
keys *          # 查看所有键
dbsize          # 数据库内键值对个数
exists          # 键是否存在
del             # 删除键
expire          # 设置过期时间
ttl / pttl      # 查看过期时间
type            # 键值对类型
strlen          # 值长度/元素个数
get / mget / getnx / getex      # 获取键的值
incr / decr / incrby / decrby / incrbyfloat     # 值自增（整数/浮点数）
</code></pre><h2 id="简单示例">简单示例</h2>
<pre><code class="language-redis" data-lang="redis"># 插入键值对
127.0.0.1:6379&gt; set python hello
OK
# 查看所有键
127.0.0.1:6379&gt; keys *tianjia
1) &quot;go&quot;
2) &quot;java&quot;
3) &quot;redis&quot;
4) &quot;python&quot;

# 获取值
127.0.0.1:6379&gt; get java
&quot;no&quot;
# 存在键
127.0.0.1:6379&gt; exists java
(integer) 1

# 插入一个列表类型的键值对
127.0.0.1:6379&gt; rpush mylist a b c d e f g
(integer) 7
# 查看键总数
127.0.0.1:6379&gt; dbsize
(integer) 4
</code></pre><h2 id="其他命令">其他命令</h2>
<pre><code>append          # 字符串附加
rename          # 重命名
randomkey       # 随机抽取键


# 数据库命令
select          # 选取数据库
migrate         # 数据库迁移
flushdb / flushall  # 删除(所有)数据库
</code></pre><h1 id="数据结构">数据结构</h1>
<h2 id="字符串">字符串</h2>
<p>字符串是redis中最基础的数据结构，键都是字符串类型。</p>
<p>字符串类型的值实际可以是字符串(简单的字符串、复杂的字符串(例如JSON、XML))、数字(整数、浮点数),甚至是二进制(图片、音频、视频),但值最大不能超过512MB</p>
<h3 id="内部编码">内部编码</h3>
<ol>
<li><strong>int</strong> ：8个字节的长整型。</li>
<li><strong>embstr</strong> ：小于等于39个字节的字符串。</li>
<li><strong>raw</strong> ：大于39个字节的字符串。</li>
</ol>
<h2 id="哈希">哈希</h2>
<p>在Redis中,哈希类型是指键值本身又是一个键值对结构,哈希中的映射关系叫作field-value</p>
<h3 id="命令">命令</h3>
<p>哈希的全局命令基本与字符串的相同，只是在细节上以及内部实现上有一些区别</p>
<pre><code>hset / hmset    # 设置键值对
hget / hmget    # 获取
hdel            # 删除
hlen            # 计算field个数
hexists         # 判断field是否存在
hkeys           # 获取所有field
hvals           # 获取所有value
hgetall         # 获取所有的field-value
hstrlen         # 计算value的字符串长度
</code></pre><h3 id="内部编码-1">内部编码</h3>
<ol>
<li><strong>ziplist(压缩列表)</strong>：当哈希类型元素个数小于hash-max-ziplist-entries
配置(默认512个)、同时所有值都小于hash-max-ziplist-value配置(默认64
字节)时,Redis会使用ziplist作为哈希的内部实现,ziplist使用更加紧凑的
结构实现多个元素的连续存储,所以在节省内存方面比hashtable更加优秀。</li>
<li><strong>hashtable(哈希表)</strong>：当哈希类型无法满足ziplist的条件时,Redis会使
用hashtable作为哈希的内部实现,因为此时ziplist的读写效率会下降,而
hashtable的读写时间复杂度为O(1)</li>
</ol>
<h2 id="列表">列表</h2>
<p>列表中的每个字符串称为元素(element),一个列表最多可以存储 2^32-1 个元素</p>
<p>特点:
有序，支持索引，支持元素重复</p>
<h3 id="命令-1">命令</h3>
<table>
<thead>
<tr>
<th align="center">操作类型</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">添加</td>
<td align="center">lpush rpush linsert</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">lpop rpop lrem ltrim</td>
</tr>
<tr>
<td align="center">查</td>
<td align="center">lrange lindex llen</td>
</tr>
<tr>
<td align="center">更改</td>
<td align="center">lset</td>
</tr>
<tr>
<td align="center">阻塞操作</td>
<td align="center">blpop brpop</td>
</tr>
</tbody>
</table>
<h3 id="内部编码-2">内部编码</h3>
<ol>
<li><strong>ziplist(压缩列表)</strong>:当列表的元素个数小于list-max-ziplist-entries配置
(默认512个),同时列表中每个元素的值都小于list-max-ziplist-value配置时
(默认64字节),Redis会选用ziplist来作为列表的内部实现来减少内存的使
用。</li>
<li><strong>linkedlist(链表)</strong>:当列表类型无法满足ziplist的条件时,Redis会使用
linkedlist作为列表的内部实现</li>
<li>quicklist: 以一个ziplist为节点的linkedlist</li>
</ol>
<h2 id="集合">集合</h2>
<p>特点：
无序，去重</p>
<h3 id="命令-2">命令</h3>
<p>集合内部</p>
<pre><code>sadd        # 添加
srem        # 删除
scard       # 计算元素个数
sismember   # 判断元素是否在集合中
srandmember # 随机返回指定个数的元素
spop        # 随机弹出元素
smembers    # 获取所有元素
</code></pre><p>集合间</p>
<pre><code>sinter      # 交集
sunion      # 并集
sdiff       # 差集
sinterstore # 求交集，并将结果保存，下同
sunionstore
sdiffstore
</code></pre><h3 id="内部编码-3">内部编码</h3>
<ol>
<li><strong>intset(整数集合)</strong>:当集合中的元素都是整数且元素个数小于set-max-
intset-entries配置(默认512个)时,Redis会选用intset来作为集合的内部实
现,从而减少内存的使用。</li>
<li><strong>hashtable(哈希表)</strong>:当集合类型无法满足intset的条件时,Redis会使
用hashtable作为集合的内部实现</li>
</ol>
<h2 id="有序集合">有序集合</h2>
<h3 id="特点">特点</h3>
<p>有序，去重，通过分值实现有序，分值可重</p>
<h3 id="操作命令-1">操作命令</h3>
<p>有序集合的全局命令基本与集合相同，但还是有一些变化</p>
<p>集合内部</p>
<pre><code>zadd
zrem
zcard
zscore                  # 获取成员分值
zrank / zrevrank        # 计算成员排名，根据分值默认从低到高
zincrby                 # 增加成员分值
zrange / zrevrange      # 返回指定排名范围的成员
zrangebyscore / ...
zcount                  # 返回指定分数范围成员个数
zremrangebyrank         # 删除指定排名内的升序元素
zremrangebyscore
</code></pre><p>集合间</p>
<pre><code>zinterstore     # 交集
zunionstore     # 并集
</code></pre><h3 id="内部编码-4">内部编码</h3>
<ol>
<li><strong>ziplist(压缩列表)</strong>:当有序集合的元素个数小于zset-max-ziplist-
entries配置(默认128个),同时每个元素的值都小于zset-max-ziplist-value配
置(默认64字节)时,Redis会用ziplist来作为有序集合的内部实现,ziplist
可以有效减少内存的使用。</li>
<li><strong>skiplist(跳跃表)</strong>:当ziplist条件不满足时,有序集合会使用skiplist作
为内部实现,因为此时ziplist的读写效率会下降</li>
</ol>
<h1 id="python中的redis">python中的redis</h1>
<p>redis提供了很多的python语言的客户端，但最被广泛认可的是redis-py，本次便以redis-py 和 python3为例</p>
<h2 id="准备">准备</h2>
<p>首先要安装redis-py库</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#960050;background-color:#1e0010">$</span> pip3 install redis
</code></pre></div><p>其次还要将 redis 服务器开启，开启方式可以不一样</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">/etc/init.d/redis-server start
</code></pre></div><blockquote>
<p>redis 提供 Redis 和 StrictRedis两个类，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。官方推荐使用<code>StrictRedis</code>类。</p>
</blockquote>
<h2 id="redis连接">redis连接</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> redis

<span style="color:#75715e"># 连接本地的redis客户端，6479端口，默认为第一个数据库(0)，密码可设置</span>
r <span style="color:#f92672">=</span> redis<span style="color:#f92672">.</span>StrictRedis(host <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;localhost&#39;</span>, port <span style="color:#f92672">=</span> <span style="color:#ae81ff">6379</span>, db <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, password <span style="color:#f92672">=</span> None)
r<span style="color:#f92672">.</span>set(<span style="color:#e6db74">&#39;python&#39;</span>, <span style="color:#e6db74">&#39;hello&#39;</span>)
<span style="color:#66d9ef">print</span>(r<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;python&#39;</span>))

<span style="color:#75715e"># 显示结果为 b&#39;hello&#39;</span>
</code></pre></div><p>还可以用连接池 connection_pool</p>
<blockquote>
<p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。
可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> redis
<span style="color:#f92672">&gt;&gt;&gt;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> pool <span style="color:#f92672">=</span> redis<span style="color:#f92672">.</span>ConnectionPool(host<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;localhost&#39;</span>, port<span style="color:#f92672">=</span><span style="color:#ae81ff">6379</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> r <span style="color:#f92672">=</span> redis<span style="color:#f92672">.</span>Redis(connetion_pool <span style="color:#f92672">=</span> pool)
<span style="color:#f92672">&gt;&gt;&gt;</span> r <span style="color:#f92672">=</span> redis<span style="color:#f92672">.</span>StrictRedis(connection_pool <span style="color:#f92672">=</span> pool)
<span style="color:#f92672">&gt;&gt;&gt;</span> r<span style="color:#f92672">.</span>set(<span style="color:#e6db74">&#39;c#&#39;</span>, <span style="color:#e6db74">&#39;bu&#39;</span>)
True
<span style="color:#f92672">&gt;&gt;&gt;</span> r<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;c#&#39;</span>)
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;bu&#39;</span>
</code></pre></div><p>在python中 redis 的应用方法基本就是一般的redis应用方式，照着用就是了</p>
<h2 id="使用pipeline">使用pipeline</h2>
<p>pipeline(流水线)实际上是对一组命令进行批量操作（相当于mset,mget），即将n次客户端与redis服务端之间的往返次数（RTT）合并为一次来回，有效节约在命令传输中所损耗的时间（如网络消耗）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">&gt;&gt;&gt;</span> <span style="color:#f92672">import</span> redis
<span style="color:#f92672">&gt;&gt;&gt;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> r <span style="color:#f92672">=</span> redis<span style="color:#f92672">.</span>StrictRedis(host<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;localhost&#39;</span>,port<span style="color:#f92672">=</span><span style="color:#ae81ff">6379</span>)
<span style="color:#f92672">&gt;&gt;&gt;</span> pipeline <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span>pipeline()
<span style="color:#f92672">&gt;&gt;&gt;</span> pipeline<span style="color:#f92672">.</span>set(<span style="color:#e6db74">&#39;vc&#39;</span>, <span style="color:#ae81ff">2</span>)       <span style="color:#75715e"># 该设置并不会执行该命令，仅相当于存在一个缓冲区</span>
Pipeline<span style="color:#f92672">&lt;</span>ConnectionPool<span style="color:#f92672">&lt;</span>Connection<span style="color:#f92672">&lt;</span>host<span style="color:#f92672">=</span>localhost,port<span style="color:#f92672">=</span><span style="color:#ae81ff">6379</span>,db<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;&gt;&gt;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> pipeline<span style="color:#f92672">.</span>incr(<span style="color:#e6db74">&#39;vc&#39;</span>)         <span style="color:#75715e"># 再将vc的值加一</span>
Pipeline<span style="color:#f92672">&lt;</span>ConnectionPool<span style="color:#f92672">&lt;</span>Connection<span style="color:#f92672">&lt;</span>host<span style="color:#f92672">=</span>localhost,port<span style="color:#f92672">=</span><span style="color:#ae81ff">6379</span>,db<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;&gt;&gt;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> pipeline<span style="color:#f92672">.</span>execute()      <span style="color:#75715e"># 执行execute后客户端才会将一组预先设定的命令传送到服务器中执行</span>
[True, <span style="color:#ae81ff">3</span>]
<span style="color:#f92672">&gt;&gt;&gt;</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> r<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;vc&#39;</span>)     <span style="color:#75715e"># 现在可以从服务器中得到vc的值</span>
<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;3&#39;</span>
</code></pre></div>
        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://Shadowmaple.github.io/tags/redis/">redis</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://Shadowmaple.github.io/posts/linux-file-search/">
        <h2 class="post-title">Linux的文件查找</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 July 1, 2019
  
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Mannix
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h1 id="脚本文件的查找">脚本文件的查找</h1>
<h2 id="whcih">whcih</h2>
<p>which 用于查找可执行文件，它是根据PATH的环境变量所规定的路径来查找文件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 用法</span>
$ whcih <span style="color:#f92672">[</span>-a<span style="color:#f92672">]</span> command

<span style="color:#75715e"># 选项与参数</span>
-a 	: 列出所有的结果

<span style="color:#75715e"># 查找which的文件名</span>
$ which -a which
which: shell built-in command
/usr/bin/which
/bin/which
</code></pre></div><h1 id="文件的查找">文件的查找</h1>
<p>在linux中，有三个命令可用于文件查找：whereis, locate, find，三者有一定的区别，各有其优劣。</p>
<h2 id="whereis">whereis</h2>
<p>whereis 只是查找系统中某些特定目录下的文件，如 /bin/sbin 下面的执行文件和 /usrshare/man 下面的 <code>man page</code> 文件，所以查找的速度非常快。但它只是查找几个特定目录下的文件，查找范围十分有限。</p>
<p>可以利用 <code>whereis -l</code> 来查看 whereis 究竟查找了多少目录</p>
<p>whereis 的用法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ whereis <span style="color:#f92672">[</span>-bmsu<span style="color:#f92672">]</span> &lt;filename&gt;

<span style="color:#75715e"># 选项与参数</span>
-b	: 只查找二进制文件
-m	: 只找在说明文件manuals路径下的文件
-s	: 只找源文件
-u	: 只找不在上述三个项目中的其他特殊文件
</code></pre></div><h2 id="locate">locate</h2>
<p>locate 是从数据库（<code>/var/lib/mlocate/</code>）中查找数据，查找速度也非常快。但由于linux中的数据库默认是每天更新一次，所以当要查找在数据库更新之后才新建立的文件时，它会告诉你此文件不存在。这是一个不好的地方，但还有补救措施，可以手动更新数据库</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ updatedb
</code></pre></div><p>updatedb 会根据 <code>/etc/updatedb.conf</code> 的设置取查找系统硬盘内的文件，并更新 <code>/var/lib/mlocate</code>内的数据库文件。由于它是将数据写入数据库文件，所以需要root权限。并且因为 updatedb 是查找硬盘文件，所以可能执行速度较慢。</p>
<p>还有一点，locate 是根据用户输入的关键字与数据库的记录进行匹配，所以可以不像 whereis 一样必须输入完整的文件名，只需输入关键字即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 用法</span>
$ locate <span style="color:#f92672">[</span>-ir<span style="color:#f92672">]</span> &lt;keyword&gt;

<span style="color:#75715e"># 选项与参数</span>
-i	: 忽略大小写差异
-r	: 后面可接正则表达式的匹配方式
-c	: 只显示文件数量
-l	: 仅输出几行
-S	: 输出locate所使用的数据库文件的相关信息，包括文件目录数量

<span style="color:#75715e"># 查找关键字api，并仅显示10行</span>
$ locate -l <span style="color:#ae81ff">10</span> api

<span style="color:#75715e"># 显示查询的数据库文件信息</span>
$ locate -S
</code></pre></div><h2 id="find">find</h2>
<p>find 的功能十分强大，不但能根据文件名查找文件，还能根据时间、用户、权限、文件大小等条件查找文件，并且还可以指定查找的目录（连同子目录）进行查找。但由于它是针对硬盘进行查找，十分消耗硬盘资源，速度很慢，不推荐使用，显然whereis和locate是优先选择。</p>
<h3 id="选项与参数">选项与参数</h3>
<table>
<thead>
<tr>
<th align="center">选项与参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">-name filename</td>
<td align="center">根据文件名查找文件</td>
</tr>
<tr>
<td align="center">-size [+-]SIZE[ck]</td>
<td align="center">查找大于(+)或小于(-)SIZE大小的文件，c为bytes，k为kb</td>
</tr>
<tr>
<td align="center">-mtime [+-]n</td>
<td align="center">在n天之前(+)，第n天中，n天之内(-)修改过内容的文件</td>
</tr>
<tr>
<td align="center">-type TYPE</td>
<td align="center">根据文件类型查找，类型有<strong>f, d</strong>, b, c, l, s, p</td>
</tr>
<tr>
<td align="center">-perm [-/]mode</td>
<td align="center">查找刚好等于mode，全部囊括mode（-）和包含任一mode权限（/）的文件，mode为数字形式</td>
</tr>
<tr>
<td align="center">-atime [+-]n</td>
<td align="center">同上，被读取过的文件</td>
</tr>
<tr>
<td align="center">-ctime [+-]n</td>
<td align="center">同上，修改过状态的文件</td>
</tr>
<tr>
<td align="center">-newer file</td>
<td align="center">列出比 file 还要新的文件，file 必须包含路径（绝对相对均可）</td>
</tr>
<tr>
<td align="center">-user name</td>
<td align="center">根据用户名查找该用户的文件</td>
</tr>
<tr>
<td align="center">-uid n</td>
<td align="center">根据用户ID（为数字）查找该用户的文件</td>
</tr>
<tr>
<td align="center">-groud name</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">-gid n</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">-nouser</td>
<td align="center">查找文件的拥有者不在 /etc/passed 中</td>
</tr>
<tr>
<td align="center">-nogroup</td>
<td align="center">同上</td>
</tr>
<tr>
<td align="center">-exec cmd</td>
<td align="center">可接其他命令来处理查找到的结果</td>
</tr>
</tbody>
</table>
<h3 id="用法示例">用法示例</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ find <span style="color:#f92672">[</span>PATH<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>option<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>action<span style="color:#f92672">]</span>

<span style="color:#75715e"># 在系统下查找api.md文件</span>
$ find / -name api.md

<span style="color:#75715e"># 在当前目录下查找大于20b的文件</span>
$ find . -size +20c

<span style="color:#75715e"># 在当前目录下查找类型为目录的文件</span>
$ find . -type d

<span style="color:#75715e"># 在家目录下查找三天内修改过内容的文件</span>
$ find /home -mtime -3

<span style="color:#75715e"># 查找属于lawler的文件</span>
$ find . -user lawler

<span style="color:#75715e"># 查找权限等于0664的文件</span>
$ find . -perm <span style="color:#ae81ff">0664</span>

<span style="color:#75715e"># 在上一层目录下查找比x.md新的文件且列出详细信息，并将结果输出到a.md文件中</span>
$ find ../ -newer ./x.md -exec ls -l <span style="color:#f92672">{}</span> &gt; a.md <span style="color:#ae81ff">\;</span>
</code></pre></div><p><code>-exec</code> 参数中，<code>{}</code> 代表的是 find 查找到的结果，最后的 <code>\;</code> 代表命令的结束</p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://Shadowmaple.github.io/tags/linux/">linux</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://Shadowmaple.github.io/posts/homeworks-development-summary/">
        <h2 class="post-title">HomeWorks 后端开发总结</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 May 12, 2019
  
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Mannix
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h1 id="前言">前言</h1>
<p>一月底诞世，二月孵化，三月正式启动，直到5月11日完成并迎来小型产品发布会，前后历时约三个半月，开发历时约两个半月，在课余时间抽出零零散散的时间来写这个小项目，磕磕绊绊的。不过总算是结束了，不过听产品说可能要出2.0……（瑟瑟发抖）
说起来算是小项目，但实际上对于新手来说，涉及的东西还是需要花许些时间去学习的。
目前该版本涉及的技术：</p>
<ul>
<li>Python3.6</li>
<li>Flask框架</li>
<li>ORM</li>
<li>celery</li>
</ul>
<p>这些是比较大的部分，另外flask下面也还有flask-mail等包有使用到
后期若进行重构和2.0升级，要用到 Redis 和 Mysql</p>
<h1 id="这个项目">这个项目</h1>
<p>先简单介绍一下这个项目吧。
老师在云课堂上的布置作业，学生时常会因为这样那样的原因错过 DDL，于是期望云课堂作业提醒功能的出现。因此，针对这一需求，HomeWorks 适时出世，提供云课堂作业查看、定时提醒，以及小组任务发布、管理这两大主要功能模块。但是后来产品组的负责人将小组任务这一模块移到了2.0迭代版，所以该项目的功能主要就是云课堂作业查看以及定时提醒。</p>
<h1 id="开发过程">开发过程</h1>
<p>一开始听说要做 mini project 的时候，还在初步接触 Flask，感到一丝恐慌，觉得自己目前的能力还不足以完成项目的开发。什么是 API？怎么设计和应用数据库？如何和安卓合作对接？完全是一片茫然。所幸，伴随着开发时间的接近，开发流程的推进，伴随着学长们的指导以及自己的学习探索，这些未知都变为了已知。经过此次开发，已基本明白项目开发的大致流程以及一些基本的技术和方法。</p>
<p>二月放寒假，要说进度的话，只能说得上是学flask了，再加上被学长催着写的数据库ER图和 UML图，就这样了。（果然在家学不进去），自我检讨。</p>
<p>三月正式开发。</p>
<h2 id="api文档">API文档</h2>
<p>写 API 文档，写了 Markdown 和 YAML 两个版本的文档。学习Markdown版的还好，模仿前人的便可；但是YAML版的确实是花了许些时间，要学最基本的语法，然后模仿官方的例子来写。</p>
<h2 id="模拟登陆爬虫">模拟登陆&amp;爬虫</h2>
<p>第三方查看云课堂作业，没有学校支持的我们，拿不到云课堂数据库，只能爬虫。所以作为后端，这个项目主要就是爬虫。爬虫有两种，一种是网页爬取，另一种是 API 获取，当时是后者效率高啊，用 API 获取相关数据。</p>
<p>在这个过程中，我学会了使用 API 爬虫的正确姿势，学会了通过分析js代码得到准确的数据。</p>
<p>爬取数据的前提是要模拟登陆，云课堂的登录需要验证码，这一点会比较麻烦。但是云课堂的验证码比较简单，很容易识别，即能简单地被OCR文字识别。不过后来发现验证码可以跳过。</p>
<h2 id="api">API</h2>
<p>写 API 基本是按照书上 flask 的结构写的，照猫画虎，其实也还好。刚开始确实会有点懵，但之后就会非常熟练了。不过刚开始自己设想会用到的 API 肯定会和实际有出入的，需求也会改变，细节也会改善，之后便会有删减，正常2333。</p>
<h2 id="邮件提醒">邮件提醒</h2>
<p>首先进行邮箱的验证，即发送验证码。这里的验证我使用 username+验证码+时间戳生成一个token字符串，发送给前台，验证的时候利用该字符串、邮箱和用户输入的验证码进行验证。这一方法不太好，应该用 Redis 来处理。后期如果重构的话会用 Redis 更改。</p>
<p>定时提醒功能使用celery，用celery异步发送邮件的困难主要在于用于发送的邮件问题，这一点上花了比较长的时间，刚开始用的邮箱因为之前测试时候发送邮件太频繁了，导致经常被服务器标志为垃圾文件……曾用多个邮箱进行测试（gmail，qq，163，189），在发送邮件上还是用qq比较好，gmail在国内受到的阻力有点大。</p>
<p>然后就是调整对应时间节点的定时邮件发送了，这也花了一定的时间进行测试、调整。</p>
<p>呃，现在来看好像也没什么的，但在之前似乎就是花了比较长的时间。</p>
<h2 id="部署">部署</h2>
<p>在阿里云学生机上部署，不知道用git克隆就行了，还在网上琢磨了好久的FTP……</p>
<p>用<code>nohup</code>使得程序在后台持续运行，不会因为终端的退出之类的事件导致进程终止。</p>
<p>在部署期间，get到了ps进程、nohup等新的技能，并对服务器的部署有了大致的了解。</p>
<h1 id="总结">总结</h1>
<ul>
<li>要和产品沟通好，明确需求，不能动不动就改动API</li>
<li>在命名上面花的时间有点长了</li>
<li>代码块要加注释，方便他人了解以及后期的修改与维护</li>
<li>说实话，写API，以及之后的改bug是件非常快乐的事情（感觉太年轻了）</li>
</ul>
<p>希望之后做其他项目能吸取教训</p>
<p>最后再放两张项目的截图：</p>
<p><!-- raw HTML omitted --></p>
<p><!-- raw HTML omitted --></p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://Shadowmaple.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">项目开发</a>&nbsp;
        
        <a href="https://Shadowmaple.github.io/tags/%E5%90%8E%E7%AB%AF/">后端</a>&nbsp;
        
        <a href="https://Shadowmaple.github.io/tags/homeworks/">HomeWorks</a>&nbsp;
        
        <a href="https://Shadowmaple.github.io/tags/%E9%9A%8F%E7%AC%94/">随笔</a>&nbsp;
        
    </div>
    

</article>
          
            <article class="post-preview">
    <a href="https://Shadowmaple.github.io/posts/linux-file-permissions/">
        <h2 class="post-title">Linux的文件属性与权限</h2>
        
        
        
    </a>

    <p class="post-meta">
        <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 May 10, 2019
  
  
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Mannix
    
  
  
</span>


    </p>
    <div class="post-entry">
        
        <h1 id="权限身份">权限身份</h1>
<p>三种身份：</p>
<ol>
<li>用户 User</li>
<li>群组 Group</li>
<li>其他人 Others</li>
</ol>
<p>用户身份和用户组记录的文件：</p>
<ul>
<li>/etc/passwd ： 存储系统账户、一般用户和root账户的相关信息（默认情况下）</li>
<li>/etc/shadow ： 记录个人密码</li>
<li>/etc/group ： 记录所有组名</li>
</ul>
<h1 id="文件属性">文件属性</h1>
<pre><code>➜  HomeWorks 21:15:00 git:(master) ls -l
total 132
-rw-rw-r-- 1 lawler lawler 26041 4月  17 21:19 apiDoc.yaml
-rw-rw-r-- 1 lawler lawler  9355 4月  17 21:20 api.md
drwxrwxr-x 5 lawler lawler  4096 5月   4 14:58 app
-rw-r--r-- 1 lawler lawler 32768 4月  23 09:48 app.db
-rw-rw-r-- 1 lawler lawler 16384 4月  25 22:42 celerybeat-schedule
-rw-rw-r-- 1 lawler lawler   201 4月  16 15:22 celeryout.file
-rw-rw-r-- 1 lawler lawler   194 4月  16 08:08 celery_run.py
-rw-rw-r-- 1 lawler lawler  1199 4月  23 09:49 config.py
-rw-rw-r-- 1 lawler lawler    97 5月   4 23:44 manage.py
-rw-rw-r-- 1 lawler lawler   244 4月  16 15:19 myout.file
drwxrwxr-x 2 lawler lawler  4096 4月  23 09:49 __pycache__
-rw-rw-r-- 1 lawler lawler    55 3月  17 00:14 README.md
-rw-rw-r-- 1 lawler lawler   192 4月  17 21:48 requirement.txt
-rw-rw-r-- 1 lawler lawler   116 3月  30 17:36 run.sh
-rw-rw-r-- 1 lawler lawler   873 3月  17 12:00 test.py
</code></pre><p>第一栏：文件的类型和权限
第一个字符表示文件的类型，permssion
d是目录，【-】是文件，【l】是链接文件，【b】为设备文件里的可供存储的周边设备，【c】为设备文件里面的串行端口设备，如键盘鼠标（一次性读取设备）
接下来的字符
rwx：可读可写可执行（read, write, execute）
分为三组，分别是文件拥有者的权限，该用户组的权限，其他人的权限</p>
<p>第二栏：链接节点数，incode
第三栏：拥有者账号
第四栏：所属用户组
第五栏：容量大小，默认为 Bytes
第六栏：最近的修改时间。格式为日期（月/日）和时间，但若时间过久远，便会仅显示日期和年份。使用<code>ls -l --full-time</code>显示完整的时间格式
第七栏：文件名</p>
<h1 id="权限意义">权限意义</h1>
<table>
<thead>
<tr>
<th align="center">组件</th>
<th align="center">ｒ</th>
<th align="center">w</th>
<th align="center">x</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">文件</td>
<td align="center">读取文件内容</td>
<td align="center">修改文件内容</td>
<td align="center">执行文件</td>
</tr>
<tr>
<td align="center">目录</td>
<td align="center">读到文件名，读取目录结构列表</td>
<td align="center">修改文件，包括增删文件、更名、移动</td>
<td align="center">进入目录</td>
</tr>
<tr>
<td align="center">注：</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>在 Linux 下，<input checked="" disabled="" type="checkbox"> 权限决定文件能否被执行，这和 Windows 有所不同</li>
<li>文件有 [w] 权限只能对文件内容进行修改，不包含该文件的删除</li>
<li>若目录无 [r] 权限，则无法 list ，在某些系统和shell上甚至无法使用 [tab] 进行自动补全</li>
<li>从网络上下载一个文件时，其属性和权限会发生改变</li>
</ol>
<h1 id="修改文件属性和权限">修改文件属性和权限</h1>
<p>chgrp： 修改文件所属用户组
chown： 修改文件拥有者以及用户组
chmod： 修改文件权限</p>
<h2 id="chgrp">chgrp</h2>
<pre><code># 格式
$ chgrp [option] grouup filename

# -R 为递归修改
$ chgrp -R lawler blog/
</code></pre><h2 id="chown">chown</h2>
<pre><code># 格式
$ chown [option] user filename
$ chown [option] user:group filename    # 也可用小数点[.]来间隔

# 例子
# chown lawler:lawler test.c
</code></pre><h2 id="chmod">chmod</h2>
<p>数字类型权限表示：<code>rwx</code> &ndash;&gt; 421
符号类型权限表示：</p>
<ul>
<li><code>+ - =</code> &ndash;&gt; 加入，移除，设置</li>
<li><code>u g o a</code> &ndash;&gt; user，group，others，all</li>
</ul>
<pre><code># 格式
$ chmod [option] mode filename

# 例子
# 数字类型修改
$ chmod 654 test.sh     # 更改后为 -rw-r-xr--

# 符号类型修改
$ chmod u=rwx,go=rx test.sh     # 设置user为读写执行，用户组和其他为读执行
$ chmod -R a+x blog/       # 都加上可执行权限（该目录递归添加）
</code></pre><h1 id="默认权限">默认权限</h1>
<p>在一个文件或目录建立的时候，所使用的是系统提供的默认权限。umask 就是指定用户的默认权限值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># 一般权限显示的是数字</span>
$ umask
<span style="color:#ae81ff">002</span>

<span style="color:#75715e"># 符号类型显示</span>
$ umask -S
u<span style="color:#f92672">=</span>rwx,g<span style="color:#f92672">=</span>rwx,o<span style="color:#f92672">=</span>rx
</code></pre></div><p>但要注意，umask 显示的权限值所代表的是该默认值需要减去的权限。用户建立一个文件的默认最大权限为666，而目录默认最大权限为777，则各自减去默认权限值则分别为：<code>-rw-rw-r--</code>，<code>drwxrwxr-x</code>。</p>
<h1 id="特殊权限">特殊权限</h1>
<h2 id="suid">SUID</h2>
<p>Set UiD，简称为SUID，是出现在用户上的一个特殊权限（s），代表在执行特定命令中，不具有该文件所有权的该用户可以暂时获得权限。</p>
<p>SUID的限制与功能：</p>
<ul>
<li>SUID权限仅对二进制程序有效</li>
<li>执行者对于改程序需要有可执行权限</li>
<li>本权限仅在执行该程序的过程中有效</li>
<li>执行者将具有改程序拥有者的权限</li>
</ul>
<p>例如二进制可执行程序 passwd（<code>/usr/bin/passwd</code>）具有s权限，所以可以修改root用户的<code>/etc/shadow</code>，但cat（<code>/bin/cat</code>）不具有SUID权限，所以不能读取<code>/etc/shadow</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ll /usr/bin/passwd
-rwsr-xr-x <span style="color:#ae81ff">1</span> root root 59K 1月  <span style="color:#ae81ff">25</span>  <span style="color:#ae81ff">2018</span> /usr/bin/passwd

$ ll /bin/cat
-rwxr-xr-x <span style="color:#ae81ff">1</span> root root 35K 1月  <span style="color:#ae81ff">18</span>  <span style="color:#ae81ff">2018</span> /bin/cat
</code></pre></div><p>另外要注意，SUID仅对二进制（可执行）程序有效，对shell脚本和目录无效。</p>
<h2 id="sgid">SGID</h2>
<p>Set GID，简称为SGID，是出现在用户组上的一个特殊权限（s），它与SUID类似，但可以针对二进制可执行文件和目录设置。</p>
<p>对文件的限制功能：</p>
<ul>
<li>SGID对二进制程序有效</li>
<li>程序执行者对于改程序需具备x权限</li>
<li>执行者在执行过程中能够短暂获得程序用户组的支持</li>
</ul>
<p>对目录的限制与功能：</p>
<ul>
<li>用户若对于此目录具有r和x的权限时，该用户可进入此目录</li>
<li>用户在此目录下的有效用户组将会变成该目录的用户组</li>
<li>若用户在此目录下具有w的权限（可新建文件），则用户所建立的新文件所属的用户组与此用户组相同</li>
</ul>
<p>在目录下的功能，就是我将短暂具有该目录用户组的身份，并在此新建的东西都会变成这个用户组的，而不是我本身所属的用户组。</p>
<h2 id="sbit">SBIT</h2>
<p>Sticky Bit，简称为SBIT，是一个在其他权限组上的一个特殊权限（t），它只针对目录有效，它表示</p>
<p>SBIT的限制与功能：</p>
<ul>
<li>当用户对于该目录具有w和x权限，即具有写入的权限</li>
<li>当用户在该目录下建立文件或目录时，仅有自己和root才有权利删除该文件</li>
</ul>
<p>就是说我在这个目录建立了一个文件，我和root可以对它进行删除、更名、移动等一系列操作，但是他人不可删除我这个文件，我也不可以删除他人建立的文件</p>
<h2 id="权限设置">权限设置</h2>
<p>设置SUID、SGID、SBIT权限的方式也是数字形式，但是原有的三位数字权限将会变为四位数字权限，第一位为特殊权限，其中SUID为4，SGID为2，SBIT为1。例如 4664 则为具有SUID权限。</p>
<p>用chmod设置即可，数字法设置的区别只是多了一位代表特殊权限的数字而已。也可以通过符号法来设置，SUID为 u+s，SGID为 g+s，SBIT为 o+t，这是加，减去则为-，大体相同。</p>
<p>但是当user、group、others不既有x的可执行权限时，设置了特设权限，这个特殊权限会变成大写（S和T），代表这个权限是空的。</p>

        
    </div>

    
    <div class="blog-tags">
        
        <a href="https://Shadowmaple.github.io/tags/linux/">linux</a>&nbsp;
        
    </div>
    

</article>
          
        </div>
        
          <ul class="pager main-pager">
            
              <li class="previous">
                <a href="https://Shadowmaple.github.io/posts/page/1/">&larr; 上一页</a>
              </li>
            
            
              <li class="next">
                <a href="https://Shadowmaple.github.io/posts/page/3/">下一页 &rarr;</a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              Mannix
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2018 - 2020
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://Shadowmaple.github.io">Mannix&#39;s blog</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          由 <a href="https://gohugo.io">Hugo v0.68.3</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> 移植自 <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://Shadowmaple.github.io/js/main.js"></script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://Shadowmaple.github.io/js/load-photoswipe.js"></script>









    
  </body>
</html>

